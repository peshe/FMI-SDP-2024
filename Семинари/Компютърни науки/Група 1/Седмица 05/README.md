# Опашка (Queue), Dequeue, Priority queue, 


Структура от данни, която подобно на стека има доста бързи операции, но за сметка на това ни дава достъп само до един елемент. Разликата от стек е в подредбата на данните в структурата. 

# Основен принцип 
## FIFO
**F** - First 
**I** - In
**F** - First 
**O** - Out

# Основни операции в опашка

1. **enqueue** - Добавяне на елемент
2. **front** - Връщане на най-рано добавения елемент
3. **dequeue** - Премахване на най-рано добавения елемент
4. **empty** - Проверка за това дали е празна

Абстрактни очаквания за сложност

|№|Операция|Име на операция| Сложност по време|
|-|-|-|-|
|1|Добавяне на елемент|enqueue| O(1)|
|2|Връщане на най-рано добавения елемент|front| O(1)|
|3|Премахване на най-рано добавения елемент|dequeue| O(1)|
|4|Проверка дали е празна|empty|O(1)|

---


# Видове Имплементация на Опашки

1. **Масив**:
   - Статична имплементация
   - Динамична имплементация

2. **Едносвързан списък**:
---

## Имплементация със статичен масив(Последователна имплементация)
Ако искаме да имплементираме опашка със статичен размер, т.е. паметта, която да използва да е една и съща и да се определя при създаването, достигаме до няколко проблема.

- Можем да препълним опашката.
- Ако имплементираме опашката по подобен начин на стека, ще получим доста по-бавни операции или ще стане така, че ще имаме заделена памет, но няма да можем да я използваме.

Ако решим да използваме масив, в който да имаме 2 указателя: 1 към началото и 1 към края. При добавяне на елемент местим указателя за край напред, а при премахване местим указателя за начало напред, ще дойдем момент, в който няма да можем да местим указателя за край  повече, а всички елементи преди указателя за начало могат да бъдат използвани. Затова използваме по-различен похват при имплементацията на опашка със статичен масив. 
![](https://www.sahinarslan.tech/static/63103e976b608cdcdfcc43424724cddb/f704e/circular-queue-anatomy.jpg)
Ще си представим, че края на масив е свързан с началото. тук някои операции са малко по-сложни, но за сметка на това можем да използваме пълния капацитет на заделения масив.
<br>

Примерна имплементация:
```cpp
#include <iostream>
using namespace std;

class StaticCircularQueue {
private:
    size_t front;
    size_t back;
    const size_t size;
    int* data;       

public:
    StaticCircularQueue(int s): size(s+1),front(0),back(0){
        data = new int[size];
    }

    bool isEmpty() const{
        return front == back;
    }

    bool isFull() const{
        return (back + 1) % size == front;
    }

    void enqueue(int element) {
        if (isFull()) 
            throw std::overflow_error("The queue is full");
        data[back] = element;
        back = (back + 1) % size;
    }

    int dequeue() {
        int element = front();
        front = (front + 1) % size;
        return element;
    }

    int front() const{
        if (isEmpty()) {
            throw std::underflow_error("The queue is empty");
        }
        return data[front];
    }

    ~StaticCircularQueue() {
        delete[] data;
    }
};

```

## Имплементация със динамичен масив(Последователна имплементация)

Както при статичния масив тук отново имаме недостатъка, че има ситуации, в които ще имаме заделена памет но на практика не можем да я използваме при тривиална имплементация, затова отново ще използваме идеята за кръгова опашка. Разликата тук е, че ако наистина се окаже пълна ще можем да разширим масив, носител на данните.
<br>

Примерна имплементация:
```cpp
#include <iostream>
using namespace std;

class CircularQueue {
private:
    size_t front;
    size_t back;
    size_t size;
    int* data;       

    void resize(){
        int* newData = new int[2 * size];
        size_t index=0;
        for(size_t i = front; i != back; i = (i+1)%size){
            newData[index] = data[i];
            index++;
        }
        delete[] data;
        data = newData;
        size = size*2;
        back = index;
        front = 0;
    }

public:
    //неспоменатите методи са същите както при статичната имплементация

    void enqueue(int element) {
        if(isFull())
            resize();
        data[back] = element;
        back = (back + 1) % size;
    }

};
```

## Имплементация със едносвързан списък (Свързана имплементация)

Ако решим да използваме едносвързан списък можем да избягаме от проблемите при имплементация с масив. Ще записваме елементите в едносвързан списък и ще пазим указател към края на този списък.


```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedQueue {
private:
    Node* front;
    Node* rear;

public:
    LinkedQueue() : front(nullptr), rear(nullptr){}

    void enqueue(int value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            front = rear = newNode;
        } 
        else {
            rear->next = newNode;
            rear = newNode;
        }
        currentSize++;
    }

    void dequeue() {
        if (isEmpty()) {
            throw std::underflow_error("The queue is empty");
        }
        Node* temp = front;
        front = front->next;
        delete temp;
        if (isEmpty()) rear = nullptr;
    }

    int getFront() const {
        if (isEmpty()) {
            throw std::underflow_error("The queue is empty");
        }
        return front->data;
    }

    bool isEmpty() const {
        return !front;
    }

};
```
Тук предимствата и недостатъците на последователната и свързаната имплементация са същите, като при реализацията на стек [тук]("https://github.com/peshe/FMI-SDP-2024/tree/main/%D0%A1%D0%B5%D0%BC%D0%B8%D0%BD%D0%B0%D1%80%D0%B8/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8E%D1%82%D1%8A%D1%80%D0%BD%D0%B8%20%D0%BD%D0%B0%D1%83%D0%BA%D0%B8/%D0%93%D1%80%D1%83%D0%BF%D0%B0%201/%D0%A1%D0%B5%D0%B4%D0%BC%D0%B8%D1%86%D0%B0%2004")

# Приоритетна опашка

Това е вид опашка, която има два критерия за това как да извлича елементите си. Първият (по - важният) е приоритета, а вторият е времето на добавяне. Това означава, че ако имаме приоритети 1 и 2, където 2 е по-висок приоритет. За да получим елемент с приоритет 1 от тази опашка, трябва да няма елементи с приоритет 2 и също  така, този елемент трябва да е бил първият добавен с този приоритет.

Този вид опашка се използва, когато имаме нужда от приоритети на излизане от структурата. Например процесите обработвани от процесора. В ОС има процеси, които са с по-висок приоритет и по-нисък. Така процесите с по-висок приоритет се извършват първи и, то в реда на постъпване в опашката. 


## Видове приоритетни опашки
1. С краен брой приоритети 

Ако имаме краен брой приоритети например P приоритета се оказва, че можем да имплементираме такава структура, при която операциите имат следните сложности

|№|Операция|Име на операция| Сложност по време|
|-|-|-|-|
|1|Добавяне на елемент с даден приоритет|enqueue| $O(P)$ или $O(1)$|
|2|Връщане на най-приоритетния елемент|front| $O(P)$|
|3|Премахване на най-приоритетния елемент|dequeue| $O(P)$|
|4|Проверка дали е празна|empty|$O(P)$ или $O(1)$|

В случая ако P e известно от началото можем да считаме, че сложността на тези операции е $O(1)$ 
В случаите, където са посочени 2 сложности, зависи от имплементацията. 

2. С безкраен брой приоритети (числа)
 Доказано е, че ако приоритетите не предварително известни и краен брой, то няма как да извършваме добавяне и извличане за сложност по-малка от $O(log P)$. Има случаи, при които едната операция е константна, а другата логаритмична, но няма как и двете да са константни.
 За такава структура имаме няколко вида имплементации, които няма да разглеждаме в това упражнение.


 # Двустранна опашка / Дек (Dequeue)

## Операции
1. **push_front** - Добавяне на елемент отпред 
2. **push_back** - Добавяне на елемент отзад
3. **pop_front** - Премахване на елемент отпред
4. **pop_back** - Премахване на елемент отзад
5. **front** - Връщане на най-предния елемент
6. **back** - Връщане на най-задния елемент
7. **empty** - Проверка дали структурата е празна

|№|Операция|Име на операция| Сложност |
 |-|-|-|-|
| 1.| **push_front**| Добавяне на елемент отпред  | $O(1)$ |
|2. |**push_back**| Добавяне на елемент отзад | $O(1)$ |
|3. |**pop_front**| Премахване на елемент отпред | $O(1)$ |
|4. |**pop_back**| Премахване на елемент отзад | $O(1)$ |
|5. |**front**| Връщане на най-предния елемент | $O(1)$ |
|6. |**back**| Връщане на най-задния елемент | $O(1)$ |
|7. |**empty**| Проверка дали структурата е празна | $O(1)$ |


# Приложения на опашки
- Планиране на задачи
- Управление на ресурси
- Мрежови протоколи
- Уеб сървъри
- Търсене в широчина (BFS)

# Задачи

1. Имплементирайте опашка с помощта на стекове. Сложността на операциите да бъде най-много амортизирана константа.
<br>

2. Имплементирайте двустранна опашка чрез стекове. Помислете дали можете да получите сложности за операциите най-много амортизирана константа
<br>

3. Имплементирайте приоритетна опашка с краен брой приоритети. Искаме следните операции: 
   - enqueue(el, priority)
   - dequeue()
   - front()
   - empty()
Търсената времева сложност е O(P), където P e броя приоритети.

4. Имплементирайте опашка, която пази своя история на действия и може да прилага методите `undo()` и `redo()`, за връщане назад и напред. Тези операции трябва да са константни

5. Да се напише опашка, която има достъп до своя минимален елемент. Търсената сложност е амортизирана константа.