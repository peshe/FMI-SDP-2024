# Стек

Структура, който за разлика от динамичния масив **не** ни предоставя директен достъп до всички елементи, а само до последния добавен.

## FILO
**F**irst - първи
**I**n - вътре
**L**ast - последен 
**O**ut - навън

## Основни операции в структурата стек:

1. **push** - Добавяне на елемент
2. **top** - Извличане на последно добавен елемент
3. **pop** - Премахване на последно добавен елемент
4. **empty** - Проверка за това дали е празен


Абстрактни очаквания за сложност

|№|Операция| Сложност по време|
|-|-|-|
|1|Добавяне на елемент| O(1)|
|2|Извличане на последно добавен елемент| O(1)|
|3|Премахване на последно добавен елемент| O(1)|
|4|Проверка дали е празен| O(1)|


Стекът е структура, която се очаква да е доста бърза във всичките си операции. За сметка на това достъпът ни до елементи е ограничен.


## Имплементации

### 1. Последователна
Този вид имплементация се нарича така, защото данни заемат последователна памет. Използва се динамичен масив( или статичен ако искаме статичен стек) за тази имплементация

Тук съществено се използва, че добавянето и премахването на елемент от **края** на динамичен масив са константни операции. 


Примерна реализация с динамичен масив
```cpp
T* data;//носител на данни
size_t pos;

void push(T el){
    ensureSize(pos);
    data[pos++] = el;
}

T pop(){
    if (pos == 0)
        throw std::underflow_error("Stack is empty");
    return data[--pos];
}

const T& top(){
    if (pos == 0)
        throw std::underflow_error("Stack is empty");
    return data[pos-1];
}

bool emtpy(){
    return !pos; 
}
```

**Предимства** 
 - Лесен за имплементация използвайки динамичен масив
 - Добра локалност на данните

**Недостатъци**
 - При преоразмеряване операцията push може да излезе доста скъпа



### 2. Свързана имплементация

Този вид имплементация се нарича така, защото данните не са последователни и са свързани чрез указатели. Всеки елемент има адреса на следващия.

```cpp
struct Node{
    T val;
    Node* next;
}curr = nullptr;

void push(T el){
    curr = new Node(el, curr);
}
T pop(){
    T val = top();
    Node* temp = curr;
    curr = curr->next;
    delete temp;
    return val;
}

const T& top(){
    if(!curr)
        throw std::underflow_error("There are no elemnts");
    return curr->val;
}

bool empty()const{
    return !curr;
}
```

**Предимства** 
 - Броя елементи в стека не влияе на времето за добавяне на нов елемент
 - Заема памет нужна за точно броя елементи в стека

**Недостатъци**
 - Използва се допълнителна памет за указатели
 - Не оптимална локалност на данните

*В различни ситуации паметта може да е по-оптимална и при двете имплементации*

## Приложения
1. Програмния стек (Рекурсия)
2. Оценяване на изрази (Постфиксен калкулатор)
3. Валидиране на синтаксис
4. Някой алгоритми с backtracking
5. Механизми за пазене на история

## Задачи

### 1. Намиране на минимален елемент в стек

**Описание:**  
Напишете разширение на класа стек, което поддържа извличане на минимален елемент в текущото състояние на стека.
Изличането трябва да става за О(1)

**Пример:**

```
Вход: 
push(3); //[3] 
push(5); //[3,5]
push(2); //[3,5,2]
push(1); //[3,5,2,1]
push(4); //[3,5,2,1,4]
getMin(); //returns 1
pop(); //[3,5,2]
pop(); //[3,5,2,1]
getMin(); //returns 2 
```

---

### 2. Сортиране на стек

**Описание:**  
Даден е стек. Напишете функция, която сортира стека в нарастващ ред. Сложността, която искаме е $O(n^2)$ за време и $О(n)$ за памет. 

**Пример:**

Вход:
```
[3, 5, 2, 1, 4]
```

Изход:
```
[1, 2, 3, 4, 5]
```

### 3. Факториел чрез стек
Да се напише програма за изчисляване на факториел. Да се използва стек за симулиране на рекурсия.

Вход:
```
5
```

Изход:
```
120
```

---

### 4. Обръщане на изречение.

**Описание:**  
Напишете функция, която приема низ представляващ изречение, където думите са разделени с интервали. Да се напише програма, която обраща реда на думите, но запазва самите тях. 

**Пример:**

Вход:
```
The quick brown fox jumps over the lazy dog
```

Изход:
```
dog lazy the over jumps fox brown quick The
```

