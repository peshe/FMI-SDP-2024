# Динамична памет. Функции от по-висок ред. Итератори и работа с файлове.

### I. Динамична памет

Променлива
: Блок от памет, който се използва за запазване на някаква информация. Размерът на този блок зависи от типа на данни.

Указател
: Променлива с фиксиран размер спрямо архитектурата и операционната система. В него не се запазва информация, а адрес в паметта. Това позволява съществуването на указатели към указатели.


#### 1. Stack

- Паметта, която ще се задели, се определя по време на **компилация**.
- Паметта се освобождава автоматично - при излизането от scope-а,  в който е дефинирана.

#### 2. Heap

- От тук се заделя памет по време на **изпълнение** на програмата.
- Масиви и обекти без предварително да е известна големината.
- Паметта продължава да е "заета" дори и след излизане от scope-а.

#### 3. Оператор new

- Връща указтел към началото на паметта, която сме заделили.
- Заделянето на динамична памет е много "**бавна**" операция!!


#### 4. Оператор delete

- Динамична памет **НЕ** се трие автоматично, както в други езици.
- Оператор delete и delete[] - освобождава динамична памет!

### Разпределение на памет 
![](https://study.com/cimages/multimages/16/1f3a8c28-4082-4714-b6fa-6bb81804095b_screen_shot_2017-12-01_at_1.31.10_pm.png)


### II. Итератори

Итератор
: Обект, който използваме, за да си направим по-лесно обхождането на контейнери. Интерфейсът на итератора винаги е един и същ, **но имплементацията му варира спрямо структурата на контейнера.**

##### Операции с итератори
1.  Дереференция на итератор
2.  Преместване напред/назад
3.  Добавяне/изваждане на число
4.  Изваждане на итератори
5.  Сравнение на итератори


### III. Функции от по-висок ред

Функциите от по-висок ред са тези, които приемат други функции като аргументи или връщат функции като резултати. В C++ това се постига чрез използването на ламбда изрази, функционални обекти и `std::function`.

#### 1. Ламбда функции
- Ламбда функциите са анонимни функции, които могат да бъдат дефинирани директно в мястото на използване.

- Синтаксисът за ламбда функция е 
```
[captures](params){body}
```

Пример:
```cpp
auto sum = [](int a, int b) { return a + b; };
```

#### 2. std::function
- `std::function` е обект, който може да съдържа всякаква callable единица, включително функции, ламбда функции и функционални обекти.
  <br>

Синтаксис:
```
std::function<returnType(parameterTypes)> variableName;
```
<br>
Пример 1:

```cpp
#include <functional>


int main(){
    std::function<int(int, int)> add = [](int a, int b) { return a + b; };
    std::cout<<add(2,3)<<std::endl;//Output: 5 

}

```


Пример 2:

```cpp
#include <functional>

bool isOdd(int a){return a%2;}

int main(){
  
    std::function<bool(int)> oddFunc = isOdd;
    std::cout<<isOdd(3)<<std::endl;//Output: 1

}
```

#### 3. Функционални обекти (Functors)
- Това са класове, които имплементират оператора `()`.
Пример:
```cpp
struct Multiplier {
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main(){

    Multiplier m;
    std::function<int(int,int)>mult = m;
    std::cout<<m(6,3)<<std::endl;//Output: 18

}

```

Задачи за функции от по-висок ред
1. Да се реализира функцията мap с аргументи масив и функцията, която да приложи върху елементите 
2. Да се напише сортираща функция, която взима като аргумент предикатна функция и я използва като критерии за сортирането. Демонстрирайте работата на програмата с следните предикати:
   - Четен елемент е преди нечетен
   - Сравнение на остатъка при деленеие на 4


### IV.Работа с файлове

1. Видове файлове според типа данни
   - Текстови
   - Двоични

Текстови файлове
: Файлове, в които съдържанието е предназначено за четене от хора. Данните във файла са различни от паметта.

Двоични файлове
: Файлове, които съдържанието е почти точно копие на паметта

2. Видове операции по файлове
   - четене
   - писане
   - четене и писане

Поток
: абстракция с която описваме връзката между програмата и даден файл или устройство

3. Видове потоци
   - потоци за вход (istream)
   - потоци за изход (ostream)

За работа с файлове използваме билбиотеката `<fstream>` или съответните `ifstream` и `ofstream`

![](https://i.sstatic.net/NZ8ST.gif)
<br>
<br>

***Преди работа с какъвто и да е файл той трябва първо да бъде отворен от програмата.***
<br>
***Задължително след отваряне на файл в някакъв момент той трябва да бъде затворен***
<br>

`open` - метод за отваряне на файл
`close` - метод за затваряне на файл
`ifstream` - клас за четене от файл
`оfstream` - клас за писане във файл


1. Флагове
   - `good` 
     : Потокът е в добро състояние. Последната операция е била успешна.
   - `bad` - 
     : Несъвместим с `good`. Възникнала е грешка при последната операция. Например хардуерен проблем
   - `fail` - 
     : Несъвместим с `good`. Пример за този флаг е грешен формат на данните
   - `eof` 
     : Флаг за край на файла. Вдига се при опит за прочитане **след** последния символ. Заедно с него се вдига и `fail`, тъй като данните са невалидни.
   - `clear()`
     : Метод за изчистване на флаговете за грешка. Оставя само флага `good`

*При получаване на флаг за грешка операциите по потока ще бъдат неуспешни и без ефект*

*Добра практика е да се използва `good` флага за условие в цикъл вместо `eof`*

- Методи на `ifstream`
  - \>> - четене на следващото парче данни
  - get - четене на един или повече символи
  - getline - четене на реда

- Методи на `оfstream`
  - \<< - записване на стойността от променливата в потока
  - put - записване на символ в потока


#### Текстови файлове

Пример за четене от текстови файл

```cpp 
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream file("myFile.txt"); // Трябва да съществува такъв файл!!!
	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a, b;

	file >> a >> b;

	file.close();
}
```

<br>
<br>

Пример за писане в текстови файлове
```cpp
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a = 3;
	int b = 10;

	file << a << " " << b << " " << a + b << std::endl;

	file.close();
}
```

Четенето и писането се случва чрез съответно get и put указатели

Позициониране на get и put указателите
 - tellg() - Връща позицията на текущия символ в потока за четене
 - tellp() - Връща позицията на текущия символ в потока за писане
 - seekg(offset, direction) - Премества get-указателят на потока за четене с offset символа в посоката, която е посочена.
 - seekg(streampos idx) - Премества get-указателят на потока за четене на позиция idx.
 - seekp(offset, direction) - Премества put-указателят на потока за писане с offset символа в посоката, която е посочена.
 - seekp(streampos idx) - Премества put-указателят на потока за писане на позиция idx.
  
  
  offset: целочислена стойност. Отместването от direction. 
  direction: Може да заема следите стойности:
 - ios::beg - началото на файла.
 - ios::cur - текущата позиция във файла.
 - ios::end - края на файла.


#### Режими на работа
```cpp
ifstream str("file.txt", <режим на работа>);
```

Режимът на работа е комбинация от флагове
||Ефект|
|-|-|
|ios::app|Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.|
|ios::ate|Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.|
|ios::binary|Превключва режима от текстов в двоичен.|
|ios::in|Отваря файл за четене.|
|ios::out|Отваряне на файл за вмъкване. Допуска се вмъкване на произволни места във файла. Ако файлът съществува, съдържанието се изтрива.|
|ios::trunc|Ако файлът съществува, съдържанието се изтрива.|

Пример
```cpp
ofstream file("file.txt", ios::out | ios::app);
```

#### Двоични файлове

За двоичните файлове използваме следните методи:

- read(char* memoryBlock, size_t size)
- write(const char* memoryBlock, size_t size)

*Важното тук е, че се използват указатели от тип char\* , т.е. нужно е да се преобразуват адресите на променливите до тип char\**


#### Записване на проста структура в двоичен файл

Структура
```cpp
    struct Test{

        bool b;
        int x;

    };
```
<br>
<br>
Записване на структурата Test в двоичен файл

```cpp 
    Test t = { true, 45 };
    std::ofstream file("testObj.bat", std::ios::binary | std::ios::trunc);

    if(!file.is_open()) return -1;

    file.write(reinterpret_cast<const char*>(&t), sizeof(t));

    file.close();
```
<br>
<br>

Четене на структурата Test от двоичен файл
```cpp
    Test t;
    std::ifstream file("testObj.bat", std::ios::binary);
    
    if(!file.is_open()) return -1;

    file.read(reinterpret_cast<char*>(&t), sizeof(t));

    std::cout << t.b << " " << t.x << '\n';

    file.close();
```

<br>
<br>

#### Записване на масив структура от структури с масиви двоичен файл

Структура
```cpp
struct Student{
	char name[24];
	int age;
	int fn;
};
```
<br>
<br>

Записване на структурa Student в двоичен файл

```cpp
void WriteStudent(const Student &student, std::ifstream &file){
    size_t nameSize = strlen(students[i].name);
    file.write(reinterpret_cast<char const *>(&nameSize), sizeof(size_t));
    file.write(students[i].name, nameSize);
    file.write(reinterpret_cast<char const *>(&students[i].age), sizeof(int));
    file.write(reinterpret_cast<char const *>(&students[i].fn), sizeof(int));
}

```
<br>
<br>

Записване на масив от структури Student в двоичен файл

```cpp
void SaveToFile(Student const *students, size_t const count, std::ofstream &file){

	file.write(reinterpret_cast<char const *>(&count), sizeof(size_t));

	for(size_t i = 0; i < count; ++i){
        WriteStudent(students[i],file);
	}

}
```
<br>
<br>

Четене на структурa Student от двоичен файл
```cpp
void ReadStudent(Student &student, std::ifstream &f){
    size_t nameLen;
    f.read(reinterpret_cast<char *>(&nameLen), sizeof(size_t)); // First we read the size of the name!
    f.read(student.name, nameLen);
    student.name[nameLen] = '\0';
    f.read(reinterpret_cast<char *>(&student.fn), sizeof(int));
    f.read(reinterpret_cast<char *>(&student.age), sizeof(int));
    f.read(reinterpret_cast<char *>(&student.fn), sizeof(double));

}

```
<br>
<br>

Четене на масив от структури Student от двоичен файл

```cpp

    Student *ReadFromFile(size_t &studentsCount, std::ifstream &f){

	size_t numberOfStudents;
	f.seekg(0, std::ios::beg);
	f.read(reinterpret_cast<char *>(&numberOfStudents), sizeof(size_t));

	Student *ptr = new(std::nothrow) Student[studentsCount];
	if(!ptr) return nullptr;

	for(size_t i = 0; i < numberOfStudents; ++i) ReadStudent(ptr[i], f);

	return ptr;

}
```

Задачи за текстови файлове:
1. Напишете функция, която приема име на съществуващ файл и име връща броя на редовете в него.
2. Напишете функция, която приема имената на два текстови файла, в които са записани цели числа в сортиран вид. Числата са разделени с интервал. Запишете в нов файл числата от двата дайла в сортиран вид. Числата отново да са разделени с интервал.