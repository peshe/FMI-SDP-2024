# Въведение в структурите от данни

### I. Рекурсия 
Рекурсия 
: Tехника в програмирането, при която дадена функция извиква сама себе си. Използваме я при задачи, при които решението на даден проблем с дадени аргументи се нуждае от решението на същия проблем, но с различни(по-прости) аргументи. В такива ситуации винаги имаме и набор от "най-прости" аргументи. Този набор от аргументи наричаме дъно на рекурсията.

##### Задачи
1. Нека разглеждаме пешка на шахматна дъска с размери **n** х **n**. Поставяме пешката в горния ляв ъгъл и искаме да я преместим до долния десен само чрез движения надолу и надясно. По-колко начина може да се случи това.
2.  Искаме да генерираме стринг с дължина **n** съдържащ валидни комбинации от скоби. Невалидна комбинация от скоби ще наричаме такава комбинация, която има префикс с повече затварящи отколкото отварящи скоби.
3.  Дадено ни е число **n** искаме да преброим всички възможни начини да представим това число като сбор на положителни числа.
4.  Да се принтират всички подмножества на дадено множество с числа.
5.  Нека имаме дъска с размери **n** x **n** и искаме да получим разпределение на **n** царици върху дъската, така че те *"да не се бият"* (спрямо правилата в шахмата)  

### II. Сложност на алгоритми

Основен похват за оценяване на ефективността на един алгоритъм е сложността му по памет и време (приблизителна оценка). Много разпространено означение за сложност на алгоритъм е O(f), където f e функция на входните данни. При оценяването на сложност на алгоритъм, било то по памет или време, не се следи точния брой битове заети от паметта или точния брой операции изпълнени от него, а порядъка на тези количества.



***За любопитните***
Асимптотично сравнение
: $f \preceq g \quad \text{def} \iff \exists N \in \mathbb{N} \, \exists c \in \mathbb{R} \, \forall n \, (n > N \rightarrow f(n) \leq c \cdot g(n))$

Клас $O$
: $O(f) = \{g | g ⪯ f\}$

Клас $\Omega$
: $\Omega(f) = \{g | g ⪯ f\}$

Клас $\Theta$
: $Θ(f) = O(f) ∩ Ω(f)$

Амортизиран анализ 
: анализ, при който не се интересуваме от най-лошият случай при изпълнение на операция или алгоритъм, а средното време или памет, използвани от алгоритъма, при последователност от изпълненията му


### Често използвани оценки за сложност 
![](https://miro.medium.com/v2/resize:fit:828/format:webp/1*dWet_YU-5072Kcko7LzsuQ.jpeg)


***Примери***
1. Да се намери сумата на елементите в масив
```cpp
int sumArray(int* arr, size_t size) {
    int sum = 0;
    for (int i = 0; i < arr.size(); i++) {
        sum += arr[i];
    }
    return sum;
}
```
Време: $O(n)$, където n = size;
Памет: $O(1)$


2. Да се сортира масив използвайки Bubble Sort
```cpp
void bubbleSort(int* arr, int size) {
    int temp;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```
Време: $O(n^2)$, където n = size;
Памет: $O(1)$

***Задача***
1. Каква е сложността по памет и време на алгоритъма за бързо степенуване? Има ли разлика в това дали алгоритъма е имплементиран рекурсивно или итеративно?

### III.Locality
Locality
: Схема, която процесора използва с цел да оптимизира работата си. Използва се кеширане на данни, които е "доста вероятно" пак да се използват скоро. 

1. Temporal locality
:  Този тип locality e свързан с времето в което някаква памет се използва, т.е ако памет е използвана е доста вероятно следващото и използване да е скоро  

2. Spacial locality
: Този тип locality e свързан с мястото в паметта което дадена променлива използва, т.е. ако памет е използвана скоро, то е доста вероятно същата или нейна съседна да бъде използвана пак скоро.
<br>

Видеa за Locality

[Видео на доц. A. Семерджиев](https://www.youtube.com/watch?v=kcdaiPb7vaY)

[Видео с тестове](https://www.youtube.com/watch?v=EmzdmqUWq3o)