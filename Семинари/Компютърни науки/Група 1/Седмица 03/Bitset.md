# Bitset (Динамичен масив с булеви елементи)

#### Какво е Bitset?
Bitset е масив от булеви стойности. Както при нормалните масиви имаме статичен и динамичен, но тук ще се занимаваме с динамичния вариант. 

#### Защо е нужен?

Колко памет заема една променлива от тип bool?

Има ли по-оптимален начин да представяме булеви стойности?

#### Как ще имплементираме такава структура с оптимална памет?

Най-малката променлива по памет в C++ заема 1 byte = 8 bit. Следователно в нея могат да се представят 255 различни състояния на променливата. Ако искаме всеки бит да отговаря за различна булева променлива ще ни е нужно да използваме една променлива, като 8 булеви. Ще постигнем това с помощта на побитови операции


#### Преговор на побитови операции

- Побитово И (**&**)
- Побитово ИЛИ  (**|**)
- Побитово НЕ (**~**)
- Побитово ИЗКЛЮЧВАЩО ИЛИ  (**^**)
- Побитово отместване  (**<<** )  ( **>>**)

|a|b|Оператор| Резултат  |
|---|---|--------|-----------|
|10101010|10010111| a & b  | 10000010 |
|10101010|10010111| a \| b | 10111111 |
|10101010|10010111| ~ b    | 01101000 |
|10101010|10010111| a ^ b  | 00111101 |
|10101010|10010111| a << 2 | 10101000 |
|10101010|10010111| a >> 2 | 00101010 |


#### Основни операции, които ще използваме 

1. setTrue(pos)
   - mask = 1 << pos
   - value = value | mask;
2. setFalse(pos)
   - mask = 1 << pos
   - value = value & (~mask);
3. getBit(pos)
   - mask = 1 << pos
   - result = value & mask;
4. invertBit(pos)
   - mask = 1 << pos
   - value = value ^ mask;


#### Носител на информация
За носител на информацията ще използваме 
динамичен масив от тип uint8_t, като всяка променлива ще отговаря за 8 булеви стойности

При заявка за промяна или извличане на информация ще пресметнем кой бит от коя променлива ни е нужен и ще използваме по-горните методи за да извършим съответната операция.


Ще искаме нашата структура да има следната сигнатура:

```cpp
class BitSet{

    BitSet()
    BitSet(size_t size)
    ??? operator[](size_t index);
    void push_back(bool);
    void pop_back();
    size_t size()const;
    void flip();
    void flip(size_t pos);
    bool all()const;
    bool any()const;
    bool none()const;
};
```
Какъв тип трябва да връща оператор []?

Защо bool& не е валиден тип?

#### Задача:
Да се имплементира Random Access Iterator за структурата поддържащ следните операции:
- оператор *
- postfix и prefix оператори `++` и `--`
- оператори за събиране и изваждане на итератор с число `+`, `+=`, `-=`, `-`
- оператор за разлика между два итератора `-`
- оператори за сравнение: `==`,`!=`,`<`,`>`,`<=`,`>=`
- оператор `[]` 

#### Допълнителна задача 
Какво правим ако искаме да използваме по няколко бита за променлива, а не 1(в случая с булеви стойности)? Например искаме да имаме масив от числа където стойностите са от 0 до 5. Дори ако използваме масив от uint8_t, това са 255 стойности, от които ние ще използваме само 6. Има ли как да модифицираме Bitset-a, така че да пазим повече информация за всяка променлива, а не само 1 бит. За простота нека този размер е <=16 бита за да може резултатът да е от тип uint16_t. Нека новият клас получава в конструктора размера на тези променливи в битове( ако не е зададен нека той да бъде 4).