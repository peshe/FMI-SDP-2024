# Динамичен масив
Динамичният масив е една първите структури, които разглеждаме в курсовете по програмиране. За разлика от статичният масив, динамичният дава възможността да добавяме колкото елементи искаме (*стига да не препълним паметта*). Всички сме писали динамичен масив поне веднъж досега и сега можем да видим неговите плюсове и минуси.

#### Основните операции които ще разглеждаме за тази структура от данни са:

##### 1. Разглеждане на елемент на конкретна позиция

Сложността по време е: $ O(1) $, но защо?

Сложността по памет също е $O(1)$, защото не заделяме никаква допълнителна памет.

##### 2. Търсене на елемент по стойност

Сложност по памет: $O(1)$

Сложност по време: $O(n)$, където n = size

##### 3. Добавяне на елемент
#####    3.1. Добавяне отзад
Получаваме сложност по време $O(1)$, **но само когато не се налага разширение на задалената памет**. Въпреки, че в лошия случай сложността по време е $O(n)$ при еднократно разширение се оказва, че амортизираната сложност за добавяне на елемент при последователност от добавяния е $O(1)$.
Сложността по памет е $O(1)$.


#####    3.2 Добавяне на елемент на произволна позиция 
При добавянето на елемент на произволна позиция възниква проблема с подредбата на другите елементи. Тогава сложността ни за добавяне на елемент в общия случай е $O(n)$

##### 4. Изтриване на елемент

#####    4.1 Изтриване на елемент отзад
Тук сложността ни е $O(1)$ и по памет и по време

#####    4.2 ИЗтриване на елемент отзад 
Също както при добабавянето премахването на произволен елемент в общият случай е операция със сложност $O(n)$

*Забележка: Тъй като добавянето и премахването на елементи на произволни позиции не са оптимални операции не се препоръчва използването на структурата динамичен масив в ситуации, при които са ни нужни много такива операции*

##### 5. Извличане на елемент с минимална стойност 
Разглеждаме тази операция с цел да я сравним с другите структури, тъй като при някои от тях точно тя ще бъде съществена.

Сложност по време O(n)

Сложност по памет O(1)

||Операция| Сложност по време| Сложност по памет|
|---|---|---|---|
|1| Извличане на елемент на позиция| $O(1)$ | $O(1)$|
|2| Търсене на елемент по стойност| $O(n)$ | $O(1)$|
|3.1| Добавяне на елемент отзад| * $O(1)$ | * $O(1)$|
|3.2| Добавяне на елемент на произволна позиция k| $O(n-k)$ | $O(1)$|
|4.1| Премахване на елемент отзад| * $O(1)$ | * $O(1)$|
|4.1| Премахване на елемент на произволна позиция k| $O(n-k)$ | $O(1)$|
|5| Извличане на минимален елемент| $O(n)$ | $O(1)$|

*\* Амортизирана сложност*

##### Защо амортизираната сложност за операцията добавяне на елемент в края е $O(1)$?

Нека разгледаме колко операции трябва да се направят за да се добавят n елемента един по един в масива. За примера ще приемем, че масивът започва с 0 елемента след това капацитета става 1 елемент и всяко следващо разширение удвоява капацитета.

##### - Добавяне на първи елемент:
Брой операции:

1 - заделяне на 1 променлива памет

0 - копиране на предишните стойности в новозаделения масив

1 - добавяне на елемента на последна позиция

##### - Добавяне на втори елемент:
Брой операции:

2 - заделяне на 2 променлива памет

1 - копиране на предишните стойности в новозаделения масив

1 - добавяне на елемента на последна позиция

##### - Добавяне на трети елемент:
Брой операции:

4 - заделяне на 4 променлива памет

2 - копиране на предишните стойности в новозаделения масив

1 - добавяне на елемента на последна позиция

##### - Добавяне на четвърти елемент:
Брой операции:

0 - не се заделя памет, защото тя е достатъчно

0 - щом няма нова памет, не се копират елементи

1 - добавяне на елемента на последна позиция

Сега нека забележим, че за n такива операции ние ще преоразмерим размера на масива $\lceil log_2(n)\rceil$ пъти

|Номер на пореден добавен елемент|1|2|3|4|5|...|n|
|-|-|-|-|-|-|-|-|
|Брой операции за заделяне|1|2|4|0|8|...|?|

Броя заделяния: $\sum_{i=0}^{k} {2^i}$, където k = $\lceil log_2(n)\rceil$ 

$\sum_{i=0}^{k} {2^i} = \frac{1*(2^k-1)}{2-1} = 2^k -1$ 

$2^k-1$ операции по заделяне на памет 

По същите разсъждения можем да забележим, че броя операции по копиране на елементи е:
$2^{k-1}-1$ операции по копиране

И последния вид операции е добавянето на елемент на последна позиция:
n операции за добавяне на елементи в края

Общо получаваме:
$2^k-1 + 2^{k-1}-1 + n \leq 2^{k-1} * (2+1) -2 + 2^k \leq 2^{k-1} * (2 + 1 + 2) \leq 5n$
<br>
Получаваме горна граница от **5n** за добавянето на **n** елемента. Следователно средно за добавянето на един елемент са нужни не повече от **5** операции. Получаваме, че амортизираната сложност за добавяне на елемент е **$O(1)$**.