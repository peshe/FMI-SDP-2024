# Седмица 11: Дервета, итератор на дърво, std::map, std::set и пирамида(heap)

## Итератори в Дерета
*В това упражнение ще говорим само за двоични дървета.*

В двоичните дървета имаме няколко типа итератори спрямо начина на обхождане на дървото

1. Итератори за обхождане в дълбочина:
Този метод обхожда дървото, като първо се посещават възлите по децата-поддървета в дълбочина. Съществуват три основни начина на обхождане в дълбочина:

- Префиксно обхождане (Pre-order Traversal):
    
    - Ред на посещение: корен → ляво поддърво → дясно поддърво.

- Инфиксно обхождане (In-order Traversal):

    - Ред на посещение: ляво поддърво → корен → дясно поддърво.

- Постфиксно обхождане (Post-order Traversal):
    
    - Ред на посещение: ляво поддърво → дясно поддърво → корен.

2. Итератори за обхождане в ширина (Level-order Traversal):
- Ред на посещение: възлите се посещават по нива, като започва от корена и се преминава последователно през всяко ниво отляво надясно.

*Обикновено се имплементира с помощта на опашка.*

## Имплементация
[Имплементация на итератор в двоично наредено дърво](https://github.com/Miro7543/sdp-2024-2025/tree/main/week11/implementation/TreeIterator/)

---

## Приложени на двоичните наредени дървета

### std::set 

- Контейнер в C++ описващ множество(няма повторения на елементи)


### std::map
- Асоциативен контейнер в C++ описващ множество от двойки ключ-стойност. Не допускаме повторение на ключове

### За тези структури

- Имплементирани чрез балансирани двоични наредени дървета(Red-Black trees) 
- Имат варианти, които допускат повторения (std::multiset, std::multimap) 
- В такива структура не винаги ни е нужна наредба, но чрез нея успяваме да получим по-добри сложности на операциите
- Имаме следните операции:

|Име|Операция|Сложност по време| 
|:-:|-|:-:|
|size|Връща размера на контейнера|$O(1)$|
|empty|Предикат за това дали е празен контейнера|$O(1)$|
|insert|Добавяне на елемент в контейнера|$O(log_2n)$|
|erase|Премахване на един или няколко елемента от контейнера|$O(log_2n)$|
|find|Търсене на елемент(връща итератор)|$O(log_2n)$|
|count|Връща броя срещания на елемент в контейнера|$O(log_2n)$|

## Дефиниции

### Пълно дърво
- Пълно двоично дърво - двоично дърво, за което всеки връх има 0 или 2 наследника
<br>

### Идеално балансирано дърво
- Идеално балансирано дърво - Двоичното дърво T е идеално балансирано, ако T е пълно и за всеки негов връх v, лявото и дясното поддърво на $T_v$ имат равни височини.
<br>

### Почти идеално балансирано дърво
- Почти идеално балансирано - Двоичното наредено дърво T = (V, E, r) е почти идеално балансирано, ако за всеки връх v ∈ V с ляво поддърво $T^{(0)}_v$ и дясно поддърво $T^{(1)}_v$ са изпълнени следните три свойства:
1. h($T^{(1)}_v$ ) ≤ h($T^{(0)}_v$ ) ≤ h($T^{(1)}_v$ ) + 1.
2. ако h($T^{(1)}_v$) = h($T^{(0)}_v$), то $T^{(0)}_v$ е идеално балансирано.
3. ако h($T^{(1)}_v$) = h($T^{(0)}_v$) + 1, то $T^{(1)}_v$ е идеално балансирано.

### Пирамида
- Пирамида ще наричаме $H = (T, λ)$, където T = (V, E) е дърво, а λ e функция  λ : V → $\mathbb{Q}$, за която за всяко ребро (u,v) ∈ E: 

#### λ(u) ≤ λ(v).


### Двочна пирамида
- Двоична пирамида ще наричаме пирамида $H = (T , λ)$, за която $T = (V, E, r)$ е почти идеално балансирано двоично дърво.

*Може да срещнете тези пирамиди като Min-Heap, ако сравнението е наобратно се наричат Max-Heap*


## Операции

1. `getMin` - получаване на минималния елемент в пирамидата
2. `extractMin` - получаване и премахване на минималния елемент в пирамидата
3. `insert` - вмъкване на елемент в пирамидата
4. `decreaseKey` - премахване на елемент от пирамидата

### Сложности на операциите 
|Операция| Сложност по време| Сложност по памет|
|:-|:-:|:-:|
|getMin|$O(1)$|$O(1)$|
|extractMin|$O(log_2n)$|$O(1)$|
|insert|$O(log_2n)$|$O(1)$|
|decreaseKey|$O(log_2n)$|$O(1)$|

#### Помощни операции
- `Soak` - "потапя" конкретен елемент, така че структурата да остане двоична пирамида
- `Heapify` - "издига" конкретен елемент, така че структурата да остане двоична пирамида
- `BuildHeap` - създава пирамидата от подаден масив

#### Сложности на помощни операции

|Операция| Сложност по време| Сложност по памет|
|:-|:-:|:-:|
|Soak|$O(log_2n)$|$O(1)$|
|Heapify|$O(log_2n)$|$O(1)$|
|BuildHeap|$O(n)$|$O(n)$|

## Имплементация
[Имплементация на пирамида](https://github.com/Miro7543/sdp-2024-2025/tree/main/week11/implementation/heap/)


## Въпрос
Защо пирамидата се предпочита пред двоично наредено балансирано дърво за имплементация на приоритетна опашка?


## Задачи:
### Задача 1
 Да се имплементира итератор за обратната посока на двоично наредено дърво.

### Задача 2
 Колко са различните двойки върхове в дървото, така че тяхната сума да е равна на X. Решението да върви за $O(n)$ време и $O(h)$ памет. 

### Задача 3
 Да се напише програма, която по даден сортиран масив, да построи почти идеално балансирано дърво.
### [Задача 4](https://www.geeksforgeeks.org/nearly-sorted-algorithm/)
 Да се сортира почти сортиран масив. Почти сортиран масив наричаме масив, при който всеки елемент се намира на най-много k позиции от правилната си позиция. Търсим решение със сложност $O(k + n*log_2k)$  
### [Задача 5](https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/)
1. Да се слеят k на брой сортирани масива за времева сложност $O(n*k*log_2k)$