# Седмица 11 - Графи

## Дефиниция на граф
Ориентиран граф е наредена двойка (V, E), където V е множеството от върхове, а E е множеството от наредени двойки от върхове, които наричаме ребра. Ако пренебрегнем реда на компонентите в двойките в Е, получаваме неориентиран граф. Или по-просто графът е нелинейна структура от данни, която описва обекти с връзките между тях, като обектите са върховете, а връзките - ребрата. Чрез графи могат да се опишат голяма част от реалните проблеми, с които се сблъскваме всеки ден, като например пътища между градове, познанства между хора, топологии на мрежи и много други.

## Различни начини за представяне на графи
Графите могат да се представят по много различни начини в зависимост от вида на пазената информация и какви операции се очаква да се изпълняват по-често. Едни от най-популярните представяния са:

- Матрица на съседство - това представяне е валидно само когато върховете на графа са положителни цели числа. Тогава той може да се представи като булева матрица, в която имаме стойност едно в клетка (i, j), ако има ребро между i и j, иначе имаме 0. При това представяне имаме много бързи операции за проверка дали ребро съществува, както и за добавяне/премахване на ребро, но за сметка на това използваната памет е O(|V|^2) и имаме по-бавни операции по намиране на наследниците на даден връх и добавяне на връх;
- Матрица на инцидентност - отново това представяне е валидно само когато върховете на графа са положителни цели числа. Тогава той може да се представи като матрица, в която редовете представляват върховете, а колоните - ребрата. В такъв случай клетка a<sub>i, j</sub> = 1, когато реброто e<sub>j</sub> е изходящо за върха v<sub>i</sub> и  a<sub>i, j</sub> = -1, когато реброто e<sub>j</sub> е входящо за върха v<sub>i</sub>. Ако a<sub>i, j</sub> = 0, то реброто e<sub>j</sub> няма за първа компонента върха v<sub>i</sub>. Бихме предпочели това представяне пред матрица на съседство, ако имаме повече информация за ребрата на графа, отколкото за върховете му. Операциите имат подобна времева сложност, но използваната памет е O(|V|*|E|), което отново е основния проблем на това представяне;
- Списък на съседство - това представяне е валидно за произволни графи. Вместо матрица, за представяне на графа се използва асоциативен списък (списък от наредени двойки), където ключа е връх, а стойността е списък на съседите на този връх. При това представяне имаме много бързи операции по намиране на наследниците на даден връх и добавяне на връх или ребро, но за сметка на това имаме по-бавни операции по проверка за съществуване на ребро и премахване на ребро или връх. Използваната памет в случая е O(|V| + |E|);
- Списък на ребрата (списък на инцидентност) - отново това представяне е валидно за произволни графи. При него просто пазим списък от всички ребра в графа. Това представяне е много удобно, когато имаме по-чести операции свързани с ребрата на графа или имаме тегла по ребрата. Използваната памет в случая е O(|E|).

Всички тези представяния са описани за случаите, когато графите са ориентирани. Ако искаме да работим с неориентирани графи, то тогава можем просто да добавим всяко ребро по два пъти за всяка от двете посоки, в които сочи.

## Задача 01 - Граф, чрез списък на съседство
Напишете шаблон на клас `Graph`, който представлява ориентиран граф без тегла, представен чрез списък на съседство. За класа реализирайте следните методи:

- std::vector\<V> vertices() const - връща всички върхове в графа;
- LinkedList\<V> successors(const V& u) const - връща всички наследници на даден връх;
- void print() const - принтира графа на стандартния изход;
- bool has_edge(const V& u, const V& v) const - проверява дали има ребро между два върха;
- void add_vertex(const V& u) - добавя връх към графа;
- void remove_vertex(const V& u) - премахва връх от графа;
- void add_edge(const V& u, const V& v) - добавя ребро в графа между два върха;
- void remove_edge(const V& u, const V& v) - премахва ребро между два върха от графа.

### Примерни графи:
```c++
Graph<int> graph;
graph.add_vertex(1);
graph.add_vertex(2);
graph.add_vertex(3);
graph.add_vertex(4);
graph.add_vertex(5);

graph.add_edge(1, 2);
graph.add_edge(1, 3);
graph.add_edge(1, 4);

graph.add_edge(2, 1);
graph.add_edge(2, 3);
graph.add_edge(2, 5);

graph.add_edge(3, 1);
graph.add_edge(3, 2);
graph.add_edge(3, 4);
graph.add_edge(3, 5);

graph.add_edge(4, 1);
graph.add_edge(4, 3);
graph.add_edge(4, 5);

graph.add_edge(5, 2);
graph.add_edge(5, 3);
graph.add_edge(5, 4);

graph.print();

/*
1 - 2 3 4 
2 - 1 3 5 
3 - 1 2 4 5 
4 - 1 3 5 
5 - 2 3 4 
*/

Graph<int> oriented_graph;
oriented_graph.add_vertex(1);
oriented_graph.add_vertex(2);
oriented_graph.add_vertex(3);
oriented_graph.add_vertex(4);
oriented_graph.add_vertex(5);

oriented_graph.add_edge(1, 2);
oriented_graph.add_edge(1, 3);
oriented_graph.add_edge(1, 4);

oriented_graph.add_edge(2, 3);
oriented_graph.add_edge(2, 5);

oriented_graph.add_edge(3, 4);
oriented_graph.add_edge(3, 5);

oriented_graph.add_edge(5, 2);
oriented_graph.add_edge(5, 4);

oriented_graph.print();

/*
1 - 2 3 4 
2 - 3 5 
3 - 4 5 
4 - 
5 - 2 4 
*/
```

### Бонус:
Модифицирайте графа, така че ребрата да имат тегла.

## Задача 02 - Граф, чрез списък от ребрата му
Напишете шаблон на клас `Graph`, който представлява ориентиран граф без тегла, представен чрез списък от ребрата му. За класа реализирайте същия интерфейс, като този от Задача 01.

## Задача 03 - Степен на връх
```c++
template <typename V>
std::pair<unsigned, unsigned> degree(const Graph<V>& graph, const V& u);
```

Напишете функция, която приема граф и връх в него. Функцията да връща наредена двойка, където първата компонента е степента на входа, а втората - степента на изхода на този връх.

### Пример:
```c++
std::pair<unsigned, unsigned> d1 = degree(oriented_graph, 1);
std::cout << d1.first << ' ' << d1.second << '\n'; // -> 0 3

std::pair<unsigned, unsigned> d2 = degree(oriented_graph, 2);
std::cout << d2.first << ' ' << d2.second << '\n'; // -> 2 2
```

## Задача 04 - Обратен граф
```c++
template <typename V>
Graph<V> invert(const Graph<V>& graph);
```

Напишете функция, която по подаден граф връща неговия обратен. Обратен граф наричаме граф, в който всички ребра са обърнати.

### Пример:
```c++
Graph<int> inverted_graph = invert(oriented_graph);
inverted_graph.print();

/*
1 - 
2 - 1 5 
3 - 1 2 
4 - 1 3 5 
5 - 2 3 
*/
```

## Задача 05 - Ойлеров граф
```c++
template <typename V>
bool is_eulerian(const Graph<V>& graph);
```

Напишете функция, която приема неориентиран граф и проверява дали той е Ойлеров.

### Пример:
```c++
std::cout << std::boolalpha << is_eulerian(graph) << '\n'; // -> false
graph.add_vertex(6);
graph.add_edge(6, 1);
graph.add_edge(6, 2);
graph.add_edge(6, 4);
graph.add_edge(6, 5);

graph.add_edge(1, 6);
graph.add_edge(2, 6);
graph.add_edge(4, 6);
graph.add_edge(5, 6);
std::cout << std::boolalpha << is_eulerian(graph) << '\n'; // -> true
```

## Задача 06 - Обхождане в дълбочина
```c++
template <typename V>
std::vector<V> dfs(const Graph<V>& graph);
```

Напишете функция, която връща списък от върховете на графа в реда им на обхождане по схемата обхождане в дълбочина.

### Пример:
```c++
for (int v : dfs(oriented_graph)) {
  std::cout << v << ' ';
}
std::cout << '\n';

// 1 2 3 4 5 

for (int v : dfs(inverted_graph)) {
  std::cout << v << ' ';
}
std::cout << '\n';

// 1 2 5 3 4
```

## Задача 07 - Обхождане в ширина
```c++
template <typename V>
std::vector<V> bfs(const Graph<V>& graph);
```

Напишете функция, която връща списък от върховете на графа в реда им на обхождане по схемата обхождане в ширина.

## Задача 08 - Път в граф
Напишете функция, която приема граф и два върха в него. Функцията да намира, ако съществува:

- път между двата върха;
- най-късия път между двата върха;
- всички пътища между двата върха.
