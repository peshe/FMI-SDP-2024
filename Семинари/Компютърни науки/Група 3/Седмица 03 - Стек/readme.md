# Седмица 03 - Стек

## Стек като структура от данни
Стекът е структура от данни, която пази елементите в реда на тяхното добавяне, подобно на масива. Разликата с него, е че може да добавяме елемент само след последния и може да премахваме само последния добавен (откъдето идва и името на структурата, понеже може да си представим, че "трупаме" елементите един върху друг като стек). Този ред на добавяне и премахване на елементите е познат като "последният влязал, първият излязал" (LIFO - Last In First Out). Въпреки ограничения набор от операции и сравнително простата си структура, стекът е една от най-често използваните структури от данни. Причината за това е, че именно малкият брой операции позволява на структурата да бъде организирана така, че времевата сложност на операциите да бъде възможно най-малка. 

## Различни начини за имплементация на стек
Има много различни начини за имплементация на структурата от данни стек, но ние ще разгледаме 3 от тях:

- Чрез статичен масив (static stack): за вътрешната структура на данните се използва статичен масив, като се пази до кой индекс е запълнен. Добавянето и премахването на елемент стават като само преместваме индекса;
- Чрез динамичен масив (resizing stack): за вътрешната структура на данните се използва динамичен масив. На практика, при тази реализация, стекът представлява динамичен масив с ограничени операции;
- Чрез свързано представяне (linked stack): данните са организирани в свързана верига от възли, като всеки възел съдържа един елемент и указател към следващия възел във веригата. На практика, при тази реализация, стекът представлява свързан списък с ограничени операции.

## Сравнение между отделните имплементации

|         | static stack | resizing stack | linked stack |
| :-----: | :-----:      | :------:       | :-----:      |
| добавяне на елемент | O(1) | O(1) амортизирано, иначе <br> O(n) в лошия случай | O(1) |
| премахване на елемент | O(1) | O(1) | O(1) |
| достъп до последния елемент | O(1) | O(1) | O(1) |
| използвана памет | O(n), но може да съдържа много празни <br> клетки, които не могат да се <br> използват от други структури/процеси | O(n), но при преоразмеряване <br> може да достигне O(2n) | O(n), но с много допълнителна памет, <br> поради нуждата да се пазят указатели <br> с всеки елемент |
| адаптивност към кеша | много добра, поради <br> пространствената локалност | добра, но преоразмеряването води <br> до копиране на елементите на ново място <br> в паметта, което намаля адаптивността към кеша | лоша, поради това че отделните възли <br> са разположени на различни места в <br> паметта, водещо до фрагментация | 

## Задача 00 - Свързано представяне на стек
Напишете интерфейс на структурата от данни стек. Интерфейсът трябва да съдържа следните методи:

- push - добавя елемент на върха на стека;
- pop - премахва елемента на върха на стека и го връща;
- peek - връща константна референция към елемента на върха на стека;
- empty - проверява дали стекът е празен.

Напишете клас `LinkedStack`, представляващ реализация на горния интерфейс чрез свързано представяне на стека. За решаване на следващите задачи използвайте това представяне на стека.

### Бонус:
Напишете още 2 класа - `StaticStack` и `ResizingStack`, които също реализират горния интерфейс и представляват реализация на стек чрез масив, който е съответно статичен и динамичен.

## Задача 01 - Обратен полски запис
Напишете програма, която по подаден валиден аритметичен израз, съдържащ едноцифрени числа +, -, /, * и скоби, преобразува израза в обратен полски запис (или познат като постфиксен запис). За целта използвайте алгоритъма на разпределителната гара ([shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm#:~:text=In%20computer%20science%2C%20the%20shunting,abstract%20syntax%20tree%20(AST).)). Не е нужно да правите валидация на входните данни.

### Пример:
| Вход | Изход |
| :-----: | :------: |
| (1+2)*(3-4/5) | 12+345/-* |
| (1+2)*(3/4-5) | 12+34/5-* |

### Бонус:
След преобразуването на израза в обратен полски запис, програмата да пресмята израза.

## Задача 02 - Елиминиране на рекурсия чрез стек
Напишете програма, която приема масив от числа и ги сортира, използвайки алгоритъма за сортиране чрез сливане ([merge sort](https://en.wikipedia.org/wiki/Merge_sort)). За целта, вместо да използвате рекурсия, използвайте стек, чрез който да я симулирате.

### Пример:
| Вход | Изход |
| :----- | :------ |
| 2 15 1 30 4 193 6 255 4 | 1 2 4 4 6 15 30 193 255 |

## Задача 03 - Парсване на изрази
Напишете програма, която приема аритметични изрази, подобни на тези в задача 01, но освен обикновени скоби, може да съдържа също и къдрави и квадратни скоби. Програмата да проверява дали скобите са балансирани, т.е. дали всяка отваряща скоба от даден вид си има затваряща от същия вид, като между тях трябва също скобите да са балансирани.

### Пример:
| Вход | Изход |
| :----- | :------ |
| (1 + (7 - 8) * [1 / (2 + 8)]) | true |
| {7 + (6 / (9 * 8)} - 4) | false |

### Бонус:
Освен за балансирани скоби, програмата да проверява и за правилно поставени оператори. Тогава вече ще имате необходимите валидации, за да валидирате изразите в задача 01.

## Задача 04 - Следващ по-голям елемент
Напишете програма, която приема масив от числа и за всяко число от масива, извежда кое е първото число надясно от него, което е по-голямо от него (ако няма такова, да се изведе -1). Програмата трябва да работи за времева сложност от O(n), където n е броят на елементите.

### Пример:
| Вход | Изход |
| :----- | :------ |
| 4 5 2 25 | 5 25 25 -1 |
| 13 7 6 12 | -1 12 12 -1 |