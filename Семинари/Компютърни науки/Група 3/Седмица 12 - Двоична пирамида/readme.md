# Седмица 12 - Двоична пирамида

## Какво е двоична пирамида?
Двоичната пирамида е йерархична структура от данни, която има формата на двоично дърво и изпълнява следните условия:

- ключът във всеки връх е по-малък или равен от ключовете на всеки един негов наследник спрямо някаква пълна наредба на ключовете;
- двоичната пирамида трябва да бъде пълно двоично дърво. Казваме, че двоично дърво е пълно, ако всички нива, без последното, имат максималния възможен брой върхове, а ако последното ниво не е пълно, то листата в него заемат най-левите възможни позиции.

Най-важното свойство на двоичната пирамида, е че най-малкият елемент в нея, спрямо наредбата на ключовете, е в корена на пирамидата, т.е. можем да го достъпим за константно време. 

## Операции за двоична пирамида
Освен достъп до най-малкия елемент, някои от най-основните операции свързани с двоична пирамида са премахване на най-малкия елемент, добавяне на елемент и промяна на ключ на даден елемент. Поради наложените условия върху двоичната пирамида, всяка една от тези операции има сложност по време от O(log n), където n е броят на елементите в пирамидата. Други по-рядко използвани операции са търсене и премахване на елемент, които обаче имат сложност по време от O(n) (премахването може да има сложност по време O(log n), ако знаем позицията на елемента, който искаме да изтрием).

В основата на почти всяка една от горните операции, стои специалната операция heapify (sift), която най-често се разделя на две отделни операции - heapify_up и heapify_down. Тяхната цел е да възстановят първото условие на двоичната пирамида като "избутват" съответно нагоре или надолу даден елемент в пирамидата. Понеже сложността по време на тези операции е O(log n), сложността по време и на повечето операции в пирамидата също е O(log n).

## Особености на имплементацията
Въпреки, че структурата на двоичната пирамида на теория е двоично дърво, на практика тя се реализира чрез масив. За целта трябва да са спазени следните условия:

- коренът на пирамидата е с индекс 0;
- ако даден елемент е с индекс i, то неговите деца имат индекси `2 * i + 1` (лявото дете) и `2 * i + 2` (дясното дете). 

Причините за този вид имплементация са няколко, като най-важните са, че:

- имаме гаранция, че първо ще запълним най-левите елементи от всяко ниво, понеже елементите винаги се добавят в края на масива;
- можем да се възползваме от пространствената локалност на кеша;
- използваме по-малко памет;
- можем лесно да намерим родителя на даден елемент;
- имплементацията е по-проста, понеже няма нужда да се грижим за допълнителни указатели и паметта, сочена от тях.

## Разликата между двоична пирамида и приоритетна опашка
Двата термина "двоична пирамида" и "приоритетна опашка" се ползват доста често заедно и затова е добре да разберем разликите между двата. Приоритетната опашка е абстрактна структура от данни, която може да се реализира по много начини, като най-честият от тях е именно чрез двоична пирамида. Важно е обаче да не слагаме еквивалентност между двете структури, понеже приоритетната опашка има едно допълнително свойство, което не всяка двоична пирамида има - ако имаме елементи с равни ключове, редът им се определя спрямо редът им на добавяне в опашката. 

## Задача 01 - Реализация на двоична пирамида
Напишете шаблон на двоична пирамида, който съдържа следните методи:

- bool empty() const - проверява дали пирамидата съдържа елементи;
- void insert(const K& key, const V& value) - добавя нов елемент в пирамидата, независимо от това, дали съществува елемент със същия ключ;
- const V& top() const - връща стойността в корена на пирамидата, без да го променя;
- V pop() - изтрива корена на пирамидата и връща стойността, която е била в него;
- void update_key(std::size_t index, const K& new_key) - променя стойността на ключа на елемент на подадения индекс.

## Задача 02 - Пирамидално сортиране (heap sort)
Към класа от Задача 01 добавете конструктор, който приема масив и построява пирамидата от елементите в него. Напишете функция `heap_sort`, която приема масив и връща сортираната му версия, използвайки алгоритъма за пирамидално сортиране.

## Задача 03 - Сливане на две пирамиди
Към класа от Задача 01 добавете нов метод `merge`, който приема друга двоична пирамида и модифицира текущата, така че тя да съдържа елементите и от двете пирамиди.

## Задача 04 - K-ти най-малък елемент
```c++
template <typename T>
T find_kth_element(const std::vector<T>& arr, std::size_t k)
```
Напишете функция, която приема масив и число k и намира k-тия по големина елемент в масива. За решението на задачата използвайте двоична пирамида.

### Пример:
```c++
std::vector<int> arr = {19, 1, 17, 100, 2, 7, 3, 36, 25};
std::cout << find_kth_element(arr, 4) << '\n'; // -> 7
```

## Задача 05 - Медиана
```c++
std::vector<double> medians(const std::vector<double>& arr);
```
Напишете функция, която приема масив от числа и връща нов масив, съдържащ медианите на всички подмасиви на оригиналния, започващи от първия елемент.

### Пример:
```c++
for (double n : medians({19, 1, 17, 100, 2, 7, 3, 36, 25})) {
  std::cout << n << ' ';
}
std::cout << '\n';

// -> 19 10 17 18 17 12 7 12 17
```

### Обяснение:
Първият елемент е 19, след това имаме 1 и 19 - тяхната медиана е тяхното средно. След като добавим 17, броят става нечетен и взимаме средното число, което е именно 17. Като добавим 100, броят пак става четен и взимаме средното аритметично на двете средни числа, в случая - 17 и 19, което е 18 и т.н.