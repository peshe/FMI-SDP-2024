# Седмица 04 - Опашка

## Опашката като структура от данни
Опашката е структура от данни, която, подобно на динамичния масив и стека, пази елементите в реда на тяхното добавяне. За разлика от тях обаче, в опашката можем да добавяме елемент само след последния и можем да премахваме само първия добавен елемент (откъдето идва и името на структурата, понеже по този начин работят опашките в реалния свят). Този ред на добавяне и премахване на елементите е познат като "първият влязал, първият излязал" (FIFO - First In First Out). Подобно на стека, простата структура и малкият брой операции позволяват на опашката да бъде организирана така, че времевата сложност на операциите да бъде възможно най-малка. Освен това, на пръв поглед простата концепция за опашка, всъщност се оказва една от най-често срещаните концепции в софтуерната разработка - подобни FIFO структури се използват за комуникация между процеси (IPC - inter-process communication), както и за синхронизация между отделни дистрибутирани системи. Всъщност ние вече се запознахме с подобна FIFO структура - това бяха потоците (ако забравим, че имаме указателите за четене и писане), понеже можехме да четем данните от тях само в реда им на записване.

## Различни начини за имплементация на опашка
Има много различни начини за имплементация на структурата от данни опашка, но ние ще разгледаме 2 от тях:

- Чрез статичен масив (static queue): за вътрешната структура на данните се използва статичен масив, като се пазят 2 индекса - един за началото и един за края на опашката. При добавяне на елемент, индекса за край на опашката са увеличава, а при премахване - индекса за начало на опашката са увеличава. Трябва обаче да се внимава с това да няма излишества при продължителната употреба на структурата - например, ако запълним целия вътрешен масив, след премахване на елемент трябва да позволим на свободното място да бъде добавен нов елемент. За целта, когато индекса за край на опашката стигне края на масива, той трябва да се "прехвърли" в началото на масива, за да може да продължи да запълва празните клетки на масива, които са се освободили след преместването на индекса за начало на опашката. Аналогично и другият индекс също трябва да може да се "прехвърля" в началото на масива.
- Чрез свързано представяне (linked queue): данните са организирани в свързана верига от възли, като всеки възел съдържа един елемент и указател към следващия възел във веригата. Тук отново са нужни два указателя - един към началото на веригата и друг към края. При добавяне на елемент, новият възел се добавя след указателя, сочещ края, а при премахване, указателят към началото се премества към следващия възел.

## Сравнение между отделните имплементации

|         | static queue | linked queue |
| :-----: | :----------: | :----------: |
| добавяне на елемент | O(1) | O(1) |
| премахване на елемент | O(1) | O(1) |
| достъп до първия елемент | O(1) | O(1) |
| използвана памет | O(n), но може да съдържа много празни <br> клетки, които не могат да се <br> използват от други структури/процеси | O(n), но с много допълнителна памет, <br> поради нуждата да се пазят указатели <br> с всеки елемент |
| адаптивност към кеша | много добра, поради <br> пространствената локалност | лоша, поради това че отделните възли <br> са разположени на различни места в <br> паметта, водещо до фрагментация |

## Други видове опашки
Освен стандартната структура на опашката, има и други разновидности, които се ползват при нужда от повече операции или ограничения. Ще разгледаме на по-интуитивно ниво 2 такива разновидности - опашка с два края и приоритетна опашка.

Опашката с два края (double-ended queue, deque) е разширение на стандартната опашка, при която можем да добавяме елементи в началото, както и можем да премахваме елементи от края. За нейната имплементация най-често се използва подобна верига от възли, като тази, която се използва в свързаното представяне на стандартната опашка, с разликата, че във всеки възел се пази и допълнителен указател, сочещ към предишния елемент във веригата. По-нататък в курса ще видим, че всъщност опашката с два края представлява ограничен двойно-свързан списък.

Приоритетната опашка е опашка, в която обаче елементите не се пазят непременно в реда им на добавяне. Всеки елемент има асоцииран със себе си приоритет, на база на който може елементът да бъде добавен по-напред в опашката, като най-отпред в опашката стои елементът с най-висок приоритет. За реализацията на приоритетна опашка се използва структурата от данни пирамида, с която ще се запознаем по-напред в курса.

## Задача 00 - Реализация на опашка
Напишете интерфейс на структурата от данни опашка. Интерфейсът трябва да съдържа следните методи:

- enqueue - добавя елемент на последно място в опашката;
- dequeue - премахва първия елемент от опашката и го връща;
- first - връща константна референция към първия елемент в опашката;
- empty - проверява дали опашката е празна.

Напишете клас `LinkedQueue`, представляващ реализация на горния интерфейс чрез свързано представяне на опашката. За решаване на следващите задачи използвайте това представяне на опашка.

## Бонус:
Напишете клас `StaticQueue`, който също реализира горния интерфейс, но чрез статичен масив. Погрижете се да няма излишества при добавянето на елементите.

## Задача 01 - Генериране на двоични числа
Напишете програма, която приема естествено число `n` и която генерира първите `n` двоични числа.

### Пример:
| Вход | Изход |
| :----- | :------ |
| 6 | 1 10 11 100 101 110 |

## Задача 02 - Числа на Хеминг
Напишете програма, която приема естествено число `n` и която генерира първите `n` числа на Хеминг. Казваме, че едно число е число на Хеминг, ако то може да се представи като 2<sup>x</sup>.3<sup>y</sup>.4<sup>z</sup>.

### Пример:
| Вход | Изход |
| :----- | :------ |
| 15 | 1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 |

## Задача 03 - Най-къс път в лабиринт
Напишете програма, която приема естествено число `n` - размера на квадратен лабиринт, две естествени числа `start_x` и `start_y` - координатите на началната точка в лабиринта и две естествени числа `end_x` и `end_y` - координатите на крайната точка в лабиринта. След това да се въведе самият лабиринт, който е изграден само от 0 и 1, където 0 означава, че клетката е празна, а 1 - че в клетката има препятствие. Програмата да намира дължината на най-късия път от началната точка до крайната (ако има такъв).

### Пример:
```
Вход:           Изход:
5               8
0 0
4 4
0 1 0 0 0
0 0 0 1 0
0 1 1 0 0
0 1 0 0 1
0 0 0 0 0
```

### Бонус:
Вместо да извежда дължината на най-късия път, програмата да извежда самия път.

## Задача 04 - Опашка, чрез два стека
Напишете реализация на интерфейса за опашка от задача 00, като за вътрешното представяне на данните използвайте два стека.

## Задача 05 - Първи отрицателен елемент в подмасиви с фиксирана дължина
Напишете програма, която приема масив от цели числа и естествено число `n`, което е по-малко от дължината на масива. Програмата да намира първият отрицателен елемент за всеки подмасив на дадения с дължина `n`. Ако подмасив не съдържа отрицателен елемент да се извежда 0.

### Пример:
| Вход | Изход |
| :----- | :------ |
| 8 <br /> 12 -1 -7 8 -15 30 16 28 <br /> 3 | -1 -1 -7 -15 -15 0 |
