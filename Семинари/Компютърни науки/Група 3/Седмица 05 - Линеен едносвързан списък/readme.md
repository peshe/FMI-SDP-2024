# Седмица 05 - Линеен едносвързан списък

## Структура на линейния едносвързан списък
Линеен едносвързан списък е структура от данни, която представлява "верига" от елементи, които знаят кой е следващият елемент във веригата. За да се постигне това, елементите на линейния еносвързан списък представляват наредени двойки, където първият елемент от двойката съдържа стойността, която искаме да запазим в структурата, а вторият елемент представлява указател към следващата наредена двойка в списъка. Стандартно, тези двойки могат да се реализират по следния начин:

```c++
template <typename T>
struct Node {
  T data;
  Node* next;

  Node(const T& data, Node* const next = nullptr) : data(data), next(next) {}
};
```

Самият линеен едносвързан списък може да се реализира като си пазим два указателя - към първия и последния елемент във веригата. Указателят към последния елемент не е задължителен, но позволява на операциите по добавяне на елемент в края на списъка и премахване на последния елемент да работят за константно време. На практика свързаният списък е абстракция над веригата от наредени двойки, която ни предоставя по-интуитивен интерфейс за работа с нея.

## Сравнение между динамичен масив и линеен едносвързан списък
Линейният едносвързан списък представлява алтернатива на динамичния масив за съхранение на множество от елементи. Отговорът на въпроса защо бихме ползвали едното пред другото се крие в това какви операции се очаква да прилагаме по-често върху техните елементи. Нека да разгледаме предимствата и недостатъците на линейния едносвързан списък спрямо динамичния масив, за да може най-добре да разберем кога бихме предпочели да използваме списък и кога - масив:

**Предимства на линейния едносвързан списък:**
- по-бързи операции за добавяне и премахване на елемент в началото на списъка;
- при наличие на итератор - по-бързи операции за добавяне и премахване на елемент след даден елемент;
- няма излишество на памет при разширяване на списъка;
- по-ефективно съхранение на голям брой данни, понеже отпада нуждата елементите да са разположени последователно в паметта, а може да са "фрагментирани" из цялото адресно пространство.

**Недостатъци на линейния едносвързан списък**:
- по-бавен достъп до произволен елемент от списъка;
- по-бавно обхождане на елементите в списъка, поради това, че са разпръстнати из паметта (губим свойството на пространствената локалност на кеша);
- изисква повече памет, понеже елементите трябва да заделят памет и за указателя към следващия елемент;
- операциите за добавяне/премахване на елементи разширяват/смаляват размера на списъка всеки път, което в общия случай е бавна операция.

## Задача 00 - Реализация на линеен едносвързан списък с итератор
Напишете шаблон на линеен едносвързан списък, който съдържа следните базови методи:

- bool empty() const - проверява дали списъкът е празен;
- std::size_t get_size() const - достъпва броя на елементите в списъка;
- void insert_first(const T& data) - добавя елемент в началото на списъка;
- void insert_last(const T& data) - добавя елемент в края на списъка;
- void remove_first() - премахва елемента в началото на списъка;
- void remove_last() - премахва елемента в края на списъка;
- поддържане на основните операции за работа с итератор.

За списъка напишете итератор, който обхожда елементите спрямо техния ред в структурата.

## Задача 01 - Операции, работещи с итератор
Към реализацията на линейния едносвързан списък от задача 00, добавете и следните методи, които приемат итератор, представляващ позиция на елемент в списъка:

- void insert_after(const T& data, const Iterator& position) - добавя елемент след дадената позиция;
- void insert_before(const T& data, const Iterator& position) - добавя елемент преди дадената позиция;
- void remove_after(const Iterator& position) - премахва елемента след дадената позиция;
- void remove_before(const Iterator& position) - премахва елемента преди дадената позиция;
- void remove_at(const Iterator& position) - премахва елемента на дадената позиция.

## Задача 02 - Общи операции върху списъци
Към реализацията на линейния едносвързан списък от задача 00, добавете и следните методи:

- void append(const LinkedList& other) - "закача" два списъка, като се запазва реда на елементите;
- Iterator search(const T& data) const - търсене на конкретен елемент в списъка, като резултата е итератор към намерения елемент или итератор след последния елемент, ако елементът не се среща в списъка;
- void reverse() - обръща реда на елементите в списъка;
- void unique() - премахва повтарящите се елементи от списъка;
- void intersection(const LinkedList& other) - намира сечението на два списъка;
- void merge(const LinkedList& other) - слива два сортирани списъка;
- void sort() - сортира елементите в списъка.

## Задача 03 - Функции от по-висок ред върху списъци
Към реализацията на линейния едносвързан списък от задача 00, добавете и следните функции от по-висок ред:

- void filter(const std::function<bool(const T&)>& predicate) - филтрира елементите на списъка по подаден предикат;
- const T& min_by(const std::function<bool(const T&, const T&)>& comparator) const - намира максималния елемент в списъка по подадена функция за сравнение на елементите;
- LinkedList\<U> map(const std::function<U(const T&)>& f) - трансформира елементите на списъка чрез прилагането на подадената функция;
- bool any(const std::function<bool(const T&)>& predicate) const - проверява за съществуване на елемент в списъка, който отговаря на подаден предикат;
- bool all(const std::function<bool(const T&)>& predicate) const - проверява дали всички елементи в списъка отговарят на подаден предикат;
- void partition(const std::function<bool(const T&)>& predicate) - разделя списъка на две части спрямо подаден предикат.