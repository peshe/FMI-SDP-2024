# Седмица 02 - Динамичен масив, итератор, представител

## Преговор от курса по ООП
Припомнете си нещата, които сме си говорили в курса по ООП за:
- [Шаблони и динамични масиви](https://github.com/fmi-lab/oop-kn-2024-group-3-seminar/tree/main/%D0%A1%D0%B5%D0%B4%D0%BC%D0%B8%D1%86%D0%B0%2006%20-%20%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8%20%D0%BD%D0%B0%20%D0%BA%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B5)
- [Итератори](https://github.com/fmi-lab/oop-kn-2024-group-3-seminar/tree/main/%D0%A1%D0%B5%D0%B4%D0%BC%D0%B8%D1%86%D0%B0%2014%20-%20%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B8)

## Шаблонът представител (Proxy design pattern)
Шаблонът представител е шаблон за дизайн, чрез който можем, вместо да работим с оригиналния обект, да работим с обект, "представящ" се за него, който да извършва някакви допълнителни операции при извикването на методите му или при достъпа до член-данните му. Такива операции могат да бъдат например допълнителен контрол до достъпа на данните в обекта, заделяне на памет само при нужда (мързеливо), кеширане, изпълняване на някакви странични ефекти и др. За да може нашият нов обект да се "представи" за оригиниалния обект има два варианта - или новият обект да следва същия интерфейс като оригиниалния, или да може да бъде преобразуван до типа на оригиналния. 

Но защо бихме искали да създаваме нов обект, представящ се за оригиналния, вместо просто да го модифицираме? Отговорът в голяма част от случаите е - защото не можем! Например, може обектът да е част от някаква библиотека, която не можем да модифицираме, или пък методите, които използват обекта, работят само с обекти от конкретния тип. Разбира се можем да използваме шаблонът и като лесен и генеричен начин за добавяне на допълнителна логика, без да се налага създаваме някакви сложни йерархии от класове.

Ето и един пример за представител, който прави допълнителна валидация на член-данните на обекта:
```c++
class Object {
public:
  Object(int a) : a(a) {}

  int get() { return a; }

private:
  int a;
};

class Proxy {
public:
  Proxy(int a) : a(a > 0 ? a : 0) {}
  
  operator Object() {
    return Object(a);
  }

private:
  int a;
};

Object create(int a, int b) { 
  return Proxy(b - a);
}

int main() {
  Object obj1 = create(3, 5);
  Object obj2 = create(5, 3);

  std::cout << obj1.get() << '\n'; // -> 2
  std::cout << obj2.get() << '\n'; // -> 0
  return 0;
}
```

## Curiously recurring template pattern (CRTP)
Curiously recurring template pattern (CRTP) е идиом, при който даден клас наследява шаблон на клас, който има като типов аргумент даденият клас (познат е още и като F-bound polymorphism). Можем да си мислим, че по този начин постигаме "обратно" наследяване, при което родителят знае кое е детето му. Ето един пример за CRTP:

```c++
template <typename T>
class Base {
public:
  void operation() {
    static_cast<T&>(*this).implementation();
  }
};

class Derived1 : public Base<Derived1> {
public:
  void implementation() {
    std::cout << "First Derived implementation\n";
  }
};

class Derived2 : public Base<Derived2> {
public:
  void implementation() {
    std::cout << "Second Derived implementation\n";
  }
};

int main() {
  Derived1 d1;
  Derived2 d2;
  d1.operation(); // First Derived implementation
  d2.operation(); // Second Derived implementation
  return 0;
}
```

Горният пример илюстрира т.нар. статичен полиморфизъм. Понеже `Base` знае типа на наследника, то можем спокойно да преобразуваме `this` до типа на наследника и да ползваме наготово неговите методи. С една дума, в горния пример успяхме да реализираме полиморфизъм, без да се налага да използваме виртуални функции, което значително намаля количеството използвани системни ресурси за поддържането на виртуалните таблици и времето за извикването на методите. Това още се нарича "симулирано динамично свързване". Естествено, в горния пример нямаме гаранция, че типовият аргумент Т поддържа метода `implementation`, но могат да се наложат ограничения върху Т, като се използват [концепции](https://en.cppreference.com/w/cpp/language/constraints).

Освен за реализация на статичен полиморфизъм, CRTP може да се използва, когато родителският клас е абстрактен и има нужда да създаде инстанция на наследника вътре в себе си. Проблемът в случая идва от това, че не може просто да създадем инстанция на базовия клас, понеже е абстрактен, но и не знаем от кой тип точно трябва да направим инстанцията. С помощта на CRTP, базовият клас знае точно типа на наследника и може спокойно да създаде такава инстанция. Ето и пример:

```c++
template <typename T>
class Base {
public:
  T create_instance() {
    // ... some code

    T instance = T();

    // ... some more code

    return instance;    
  }
};

class Derived1 : public Base<Derived1> {
public:
  Derived1() {
    std::cout << "Derived1 constructor\n";
  }
};

class Derived2 : public Base<Derived2> {
public:
  Derived2() {
    std::cout << "Derived2 constructor\n";
  }
};

int main() {
  Derived1 d1; // Derived1 constructor
  Derived1 d1_instance = d1.create_instance(); // Derived1 constructor

  Derived2 d2; // Derived2 constructor
  Derived2 d2_instance = d2.create_instance(); // Derived2 constructor
  return 0;
}
```

Част от случаите, в които искаме да имаме подобно поведение, могат да бъдат разрешени, като направим метода, в който създаваме инстанцията, виртуален и направим типа му на връщане да е указател или референция към базови клас. Тогава можем да се възползваме от ковариатността на типа на връщане (return type covariance), така че в наследника да използваме като тип на връщане типа на самия наследник. (Къде сме виждали тази ковариантност в курса по ООП?).

## Задача 00 - Абстрактни класове за масив и итератор
Напишете шаблонен абстрактен клас `Iterator`, който задава основните операции, които съдържа един итератор. В него реализирайте методите за преместване на итератора към следващата стойност и за достъп на стойността, както за константния така и за неконстантния вариант.

Напишете шаблонен интерфейс `Array`, който задава основните операции за работа с масив:

- връщане на размера на масива;
- индексиран достъп до елемент на масив - константен и неконстантен;
- добавяне на елемент в масива след последния;
- вмъкване на елемент в масива на подадена позиция;
- премахване на елемент от масива, отговарящ на даден предикат;
- поддържане на основните операции за работа с итератор;

Сигнатурите на методите и структурата на интерфейса са по ваш избор. Интерфейсът трябва да работи за произволен вид итератор.

## Задача 01 - Шаблон на динамичен масив
Напишете шаблон на динамичен масив `DynamicArray`, който наследява интерфейса от задача 00.

Напишете шаблон на итератор `ForwardIterator`, който наследява `Iterator` и обхожда елементите в реда им в структурата.

Напишете примерна програма, която използва `DynamicArray` заедно с `ForwardIterator`, която да демонстрира коректността на реализациите. Като начален шаблон, трябва следният фрагмен да може да се компилира, ако реализацията ви е коректна:

```c++
DynamicArray<int, ForwardIterator<int>> arr;

for (std::size_t i = 0; i < 5; ++i) {
  arr.push_back(i);
}

for (int element : arr) {
  std::cout << element << ' ';
}

std::cout << '\n';
```

## Задача 02 - Представител за водене на отчет
Напишете шаблонене интерфейс `Proxy`, който представлява представител за даден тип. Интерефейсът да съдържа операторите за трансформиране до референция от дадения тип - константна и неконстантна.

Модифицирайте масива от задача 01, така че операторите за индексиран достъп да връщат представител за стойността. Модифицирайте итератора от задача 01, така че операторът за взимане на стойността да връща представител за стойността.

Напишете шаблон на представител `LoggingProxy`, който наследява интерфейса `Proxy`, така че всеки път като се опитваме да достъпим елемент на масив, води отчет за достъпа до този елемент, като за момента просто извежда на стандартния изход информация за позицията на елемента и неговата стойност.

## Задача 03*
Използвайте [концепции и ограничения](https://en.cppreference.com/w/cpp/language/constraints) на местата, където очаквате като типови аргументи итератори и представители, за да имате по-голяма типова сигурност. За целта трябва да си направите 2 нови концепции - `IteratorConcept` и `ProxyConcept`.

## Задача 04** - Синглетон
Напишете базов клас `Singleton`, който съдържа само необходимите методи и член-данни, за да се реализира шаблонът Синглетон. За целта използвайте `CRTP`, за да може да подадете конкретния тип на синглетона като типов параметър.

Напишете клас `Logger`, който наследява `Singleton` и съдържа 3 метода - log, error и debug, които приемат като аргумент символен низ и го записват съответно във файлове с имена `info.txt`, `errors.txt` и `debug.txt`.

### Упътване:
Погледнете упътването за [задача 03](https://github.com/fmi-lab/oop-kn-2024-group-3-seminar/tree/main/%D0%A1%D0%B5%D0%B4%D0%BC%D0%B8%D1%86%D0%B0%2007%20-%20%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B8%D1%80%D0%B0%D0%BD%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B5) от темата за автоматични тестове от курса по ООП.