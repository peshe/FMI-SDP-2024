# Седмица 01 - Преговор, двоични файлове

## Преговор - рекурсивни алгоритми
[Линк](https://github.com/fmi-lab/up-kn-2023-2024-group-3-seminar/tree/main/%D0%A1%D0%B5%D0%B4%D0%BC%D0%B8%D1%86%D0%B0%2011%20-%20%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F%20%D1%81%20%D0%B2%D1%80%D1%8A%D1%89%D0%B0%D0%BD%D0%B5%20%D0%BD%D0%B0%D0%B7%D0%B0%D0%B4) към материалите за курса по `Увод в програмирането` на тема `рекурсия с връщане назад`

## Задача 01 - Равни суми
```c++
std::optional<int> subset_sum(const std::vector<int>& arr);
```
Напишете функция `subset_sum`, която приема масив от числа и ако той може да се раздели на 2 подмасива с равна сума, то да връща тази сума, а иначе да връща празна стойност.

### Пример:
```c++
std::optional<int> s1 = subset_sum({1, 5, 11, 5});
std::optional<int> s2 = subset_sum({1, 3, 5, 11});

std::cout << (s1.has_value() ? std::to_string(s1.value()) : "false") << '\n'; // -> 11
std::cout << (s2.has_value() ? std::to_string(s2.value()) : "false") << '\n'; // -> false
```

## Задача 02 - Кон в лабиринт
```c++
bool knight_traversal(unsigned n, unsigned start_x, unsigned start_y, unsigned end_x, unsigned end_y);
```

Напишете функция `knight_traversal`, която приема естествено число `n` - размерът на квадратен лабиринт, две естествени числа `start_x` и `start_y` - координатите в лабиринта, на които има поставен кон, както и две естествени числа `end_x` и `end_y` . Конят може да се движи спрямо правилата за движение на кон в шаха. Функцията да проверява дали конят може да достигне до клетката с координати `end_x` и `end_y`.

### Пример:

```c++
std::cout << std::boolalpha << knight_traversal(4, 0, 0, 3, 3) << '\n'; // -> true
std::cout << std::boolalpha << knight_traversal(3, 1, 1, 2, 2) << '\n'; // -> false
```

### Бонус:
Функцията да връща масив от направените ходове на коня.

## Задача 03 - IP адреси
```c++
std::vector<std::string> generate_ip_addresses(const std::string& s);
```
Напишете функция `generate_ip_addresses`, която приема символен низ и връща масив от всички възможни IP адреси, които могат да се получат от символния низ, чрез добавянето на 3 точки в него. IP адресът се състои от 4 числа между 0 и 255, разделени с точка, като числата не могат да започват с 0.

### Пример:
```c++
for(const std::string& s : generate_ip_addresses("101023")) {
  std::cout << s << ' ';
}
std::cout << '\n';

// -> 1.0.10.23 1.0.102.3 10.1.0.23 10.10.2.3 101.0.2.3
```

## Двоични файлове срещу текстови файлове
До сега разглеждахме файловете като потоци, но всъщност с тях можем да правим доста повече неща, от тези които можем да правим с обикновените потоци. Например вече знаем, че във файловите потоци се пазят 2 указателя - един за четене и писане. Всъщност тези указатели ни дават възможност за пряк достъп до данните във файла, но за целта трябва данните в него да са добре форматирани. При текстовите файлове имаме форматиран вход и изход, т.е. данните се записват във формат, удобен за четене от хора (UTF-8 например), но в неудобен формат за четене от програмите. В този случай ние не можем да достъпваме пряко обектите, записани във файла, понеже нямаме гаранция, че всички обекти ще имат равен размер. За сметка на това пък, последователния достъп е доста лесен, особено понеже имаме операторите за форматиран вход и изход - >> и <<. За да гарантираме, че обекти от един и същи тип, ще заемат един и същи размер при запис във файла, трябва този запис да бъде неформатиран - т.е. трябва данните да бъдат записани директно като байтове, а не като кодирани символи. Файлове, които съхраняват "сурови" последователности от байтове се наричат двоични файлове. Освен, че двоичните файлове предразполагат пряк достъп до данните в тях, четенето и писането от тях е доста по-ефективно спрямо тези при текстовите файлове.

## Запис и четене от двоични файлове
За да пишем и четем от двоичен файл на първо място, трябва да отворим файла в режим за работа с двоични файлове - това става като при отварянето на файла вдигнем флага `std::ios::binary`. За работа с отворения вече двоичен файл, не можем да използваме операторите >> и <<, понеже както стана дума по-горе, те служат само за форматиран вход и изход. За работа с неформатиран вход и изход, се използват функциите `write` и `read`. Те приемат указател към масив от тип `char` и брой знаци, които да бъдат записани/прочетени (`write` и `read` не спират при срещане на терминираща нула!). Но както знаем, размерът на `char` е точно 1 байт - т.е. ако успеем да "транслираме" нашите обекти до последователност от тип `char`, то ние ще успеем да ги запишем в двоичен формат. В C++ това се постига чрез оператора `reinterpret_cast`. Чрез него ние можем да преобразуваме указател от всякакъв тип до указател от всякакъв друг тип. Това става, като се запази последователността от битове на обекта, сочен от оригиналния указател, и само се промени тяхната интерпретация спрямо типа на новия указател. Това е най-опасният вид преобразуване на типове и трябва да го използваме, само когато сме абсолютно сигурни, че знаем какво правим. Нека разгледаме пример за писане и четене от двоичен файл:

```c++
struct Triangle {
  double a, b, c;
};

int main() {
  Triangle triangle = { .a = 3, .b = 4, .c = 5};
  std::fstream file("triangle.bin", std::ios::out | std::ios::binary);

  file.write(reinterpret_cast<const char*>(&triangle), sizeof(Triangle));
  file.close();

  file.open("triangle.bin", std::ios::in | std::ios::binary);

  Triangle input;
  file.read(reinterpret_cast<char*>(&input), sizeof(Triangle));
  file.close();

  std::cout << input.a << ' ' << input.b << ' ' << input.c << '\n'; // -> 3 4 5
  return 0;
}
```

## Пряк достъп в двоични файлове
След като вече видяхме как можем да пишем и четем от двоични файлове, можем най-накрая да видим как да достъпваме пряко данни, записани в двоичен формат. Ако знаем, че файлът ни се състои от данни от еднороден тип, то можем да се отместваме на равни интервали с размер равен на един обект от този тип, за да си гарантираме, че указателят ще бъде винаги в началото на обект от този тип. Ето пример, при който искаме да вземем петия триъгълник от файл, съдържащ само триъгълници в двоичен формат:

```c++
std::fstream file("triangles.bin", std::ios::in | std::ios::binary);

Triangle input;
file.seekg(4 * sizeof(Triangle));
file.read(reinterpret_cast<char*>(&input), sizeof(Triangle));
file.close();
```

## Особености при сериализация на динамично заделени данни
Едно от най-важните неща които засегнахме при работата с двоични файлове, е че искаме сериализираните обекти да имат еднакъв размер, за да можем лесно да извършваме пряк достъп до тях. Когато обаче имаме динамично заделени данни в обектите се срещаме с нов проблем - в обекта пазим само указател към тези данни, а размерът на самите данни може да варира. Ако сериализираме само указателя, ще бъде грешно, понеже адресът сочен от него е валиден само за текущата програма - след нейното приключване паметта, сочена от него, ще бъде освободена и при последвал достъп ще получим грешка при сегментацията. Решението в случая е да запазим първо размерът на динамично заделените данни и след това да сериализираме и тях. Така, при следващо четене от файла, ще знаем колко точно байта заема нашия обект, но тогава се сблъскваме със същия проблем, който имахме и при текстовите файлове - данните имат различен размер и прекият достъп вече не е толкова лесен. Има няколко начина, по които можем да се справим с този проблем:

- да пазим в отделен файл таблица с началните позиции на всеки обект във файла;
- да пазим динамично заделените данни в отделна секция от файла и на тяхно място в обектите да пазим указател към позициите на тези данни;
- към всеки обект да запишем и заглавна част (header), която носи допълнителна информация за обекта, като например размера на данните в него и др.


## Задача 00 - Побитови операции
Да се реализират следните функции чрез употребата на побитови операции:
- void swap(int a, int b) - разменя стойностите на 2 числа;
- bool even(int a) - проверява дали подаденото число е четно;
- int change_sign(int a) - връща подаденото число с обратен знак;
- size_t ones(int a) - връща колко единици има в двоичния запис на подаденото число;
- int sum(int a, int b) - връща сбора на двете подадени числа;
- RGB extract_colors(unsigned a) - по подадено шестнайсетично число от 0x000000 до 0xFFFFFF връща наредена тройка от кода на червения, зеления и синия цвят.

## Задача 01 - Интерфейси за сериализиране и десериализиране
Да се реализира интерфейс `BinaryCodec`, който съдържа следните методи:
- void serialize(std::ofstream& file) - записва обекта в двоичен файл;
- void deserialize(std::ifstream& file) - чете обект от двоичен файл;

Да се реализира интерфейс `RandomAccessBinaryCodec`, който наследява `BinaryCodec` и съдържа следните методи:
- void serialize_at(std::ofstream& file, std::size_t pos) - записва обекта в двоичен файл на конкретна позиция;
- void deserialize_at(std::ifstream& file, std::size_t pos) - чете обект от двоичен файл от конкретна позиция.

## Задача 02 - Библиотека
Да се реализира клас `Book`, който представлява книга, която има име (до 100 символа), автор (до 50 символа) и уникален номер (положително цяло число). Класът да реализира интерфейса `RandomAccessBinaryCodec`.

Да се реализира клас `Library`, който представлява библиотека, която има име с произволна дължина и списък от книги. Класът да реализира интерфейса `BinaryCodec`. Освен това да се реализират следните методи:
- void add(const Book& book) - добавя книга към библиотеката;
- std::size_t get_list_size() const - връща размера на списъка с книгите;
- const std::string& get_name() const - връща името на библиотеката;

Да се реализира клас `LibraryHandler`, който съдържа библиотека и двоичен файл с информация за библиотеката. Да се реализират следните методи:
- LibraryHandler() - конструктор без параметри;
- LibraryHandler(const std::string& filename) - конструктор, който получава името на файла с информацията и зарежда библиотеката от този файл;
- void load(std::string& filename) - зарежда библиотеката от файл с подаденото име;
- void save() - запазва промените по библиотеката във файла;
- void add(const Book& book) - добавя книга към библиотеката;
- void replace(std::size_t index, const Book& book) - променя книгата на позиция `index` в списъка на `book`. Промяната да се отрази във файла с информацията за библиотеката, без да се сериализира цялата библиотека.