# Седмица 13 - Хеш таблица

## Абстрактната структура речник
Абстрактната структура речник (dictionary) представлява функционална връзка между две множества от елементи, които наричаме ключове и стойности. Тази структура е позната още като асоциативен списък или карта (map). Основните операции, които поддържа речника са търсене на стойност по ключ, добавяне на ключ и съответната му стойност, промяна на стойност по даден ключ, изтриване на ключ и съответната му стойност и връщане на списък от всички ключове или всички стойности. Това е една от най-често използваните структури от данни, понеже много често ни се налага да пазим елементи, които съответстват на други стойности, които обаче не са естествени числа (иначе щяхме да ползваме масиви). 

Има много различни начини, по които може да се реализира речник, като някои от тях са чрез:

- списък от наредени двойки - много проста реализация, но за сметка на това, операциите по търсене, обновяване и изтриване имат линейна сложност по време, а операцията по добавяне има константна сложност по време;
- хеш таблица - всички операции имат амортизирана константна сложност по време.

Ако искаме да поддържаме ред на елементите спрямо техните ключове, то тогава можем да реализираме речника чрез:

- сортиран масив от наредени двойки - операциите по търсене и обновяване имат логаритмична сложност по време, понеже можем да използваме двоично търсене, а операциите по добавяне и премахване имат линейна сложност по време;
- балансирано дърво за търсене - всички операции имат логаритмична сложност по време.

Ние ще разгледаме в детайли как можем да реализираме речник чрез хеш таблица.

## Какво е хеш таблица?
Хеш таблицата е масив от наредени двойки от ключ и стойност, при който имаме съответствие между ключовете и индексите на масива. Това съответствие се определя от т.нар. хеш функция. Ако **Keys** е множеството от ключове, а **n** е размера на масива, то казваме, че функцията **h: Keys -> [0, n)** e хеш функция. Стойностите на хеш функцията наричаме хеш кодове. В идеалния случай бихме искали **h** да бъде инекция, но на практика такава функция много трудно може да бъде открита и често **|Keys| > n**. Тогава със сигурност имаме случай, при който за **k1 != k2** имаме **h(k1) == h(k2)**. Тогава казваме, че има колизия между **k1** и **k2**. За случаите, когато **|Keys| > n** искаме **h** да бъде сюрекция, за да можем да запълним целия масив и също така искаме **h** да бъде равномерна, т.е. стойностите на **h** да са колкото се може по-равномерно разпределени, за да имаме минимална вероятност за колизии. За съжаление колизиите на практика са неизбежни, затова трябва да имаме стратегии за справянето с тях.

## Разрешаване на колизии
Има два основни вида стратегии за разрешаване на колизии - чрез пряко свързване и чрез отворено адресиране. При прякото свързване (познато още като отворено хеширане или затворено адресиране) елементите на масива са кофи (buckets), които съдържат всички елементи, чиито ключове имат равни хеш кодове. Ако хеш функцията е достатъчно равномерна, то във всяка кофа ще има минимален брой елементи. Тази стратегия е лесна за имплементация, но изразходва много памет при малък брой елементи. При отвореното адресиране (познато още като затворено хеширане) имаме предварително зададена пермутация на индексите. При колизия, проверяваме дали имаме колизия в следващия индекс от тази пермутация и ако не - поставяме елемента на тази позиция, в противен случай продължаваме да обхождаме пермутацията. При достигане на около 70% от капацитета на масива производителността започва да спада и затова се налага преоразмеряване на масива, което включва и повторно изчисляване на хеш кодовете на елементите. Тази стратегия е по-сложна за имплементация, но няма излишък на памет. В допълнение, пермутацията може да се задава от вторична хеш функция.

## Множество чрез речник
Множеството е абстрактна структура от данни, която съдържа всеки елемент точно по веднъж. При нея отново има много начини за реализация, но най-популярния е като се използва речник, в който ключовете са самите елементи, а стойностите са фиктивни. Тогава можем да използваме наследените операции от речника и при опит за добавяне на елемент, ако той вече съществува като ключ, можем да не го добавяме. Аналогично при търсенето - ако в речника съществува елемент с ключ равен на търсения елемент, то тогава елементът се съдържа в множеството. 

## Задача 01 - Речник и множество
Напишете шаблон на речник, реализиран чрез хеш таблица със стратегията за пряко свързване, който съдържа следните методи:

- std::optional\<V> lookup(const K& key) const - търси стойност в речника по подаден ключ;
- void set(const K& key, const V& value) - по подаден ключ и стойност, ако ключа съществува, стойността сочена от него се променя на подадената, иначе се добавя нова двойка от ключ и стойност;
- void remove(const K& key) - по подаден ключ премахва стойността, сочена от него;
- std::vector\<K> keys() const - връща всички ключове в речника;
- std::vector\<V> values() const - връща всички стойности в речника;
- необходимите методи за работа с итератор.

Напишете шаблон на множество, който наследява речника.

## Задача 02 - Хистограма
```c++
template <typename T>
Dictionary<T, unsigned> histogram(const std::vector<T>& arr);
```

Напишете функция, която по подаден масив връща неговата хистограма. Хистограма наричаме съответствие между елементите в масива и броят на срещанията им в него.

### Пример:
```c++
std::vector<int> arr{4, 7, 6, 4, 2, 1, 6, 1, 7, 1, 5, 1};
for (const KeyValuePair<int, unsigned>& pair : histogram(arr)) {
  std::cout << pair.key << " -> " << pair.value << '\n';
}

/*
1 -> 4
2 -> 1
4 -> 2
5 -> 1
6 -> 2
7 -> 2
*/
```

## Задача 03 - Сечение
```c++
template <typename T>
std::vector<T> intersection(const std::vector<T>& first, const std::vector<T>& second);
```
Напишете функция, която намира сечението на два масива. Функцията да има линейна сложност по време.

### Пример:
```c++
for (int n : intersection<int>({1, 2, 2, 3}, {2, 4, 3})) {
  std::cout << n << ' ';
}
std::cout << '\n';

// 2 3
```

## Задача 04 - Групиране
```c++
template <typename T, typename U>
Dictionary<U, std::vector<T>> group_by(const std::vector<T>& arr, const std::function<U(const T&)>& aggregator)
```

Напишете функция, която приема масив и функция, която по подаден елемент от масива връща нова стойност. Функцията да връща елементите от масива, групирани по съответните им стойности, след прилагането на подадената функция.

### Пример:
```c++
std::vector<int> arr{4, 7, 6, 2, 1, 5};
for (const KeyValuePair<bool, std::vector<int>>& pair : group_by<int, bool>(arr, [](int n){return n % 2 == 0;})) {
  std::cout << std::boolalpha << pair.key << " -> ";
  for (int n : pair.value) {
    std::cout << n << ' ';
  }
  std::cout << '\n';
}

/*
0 -> 7 1 5 
1 -> 4 6 2 
*/
```

## Задача 05 - LRU Cache
Напишете шаблон на клас `LRUCache`, който представлява кеш с фиксиран размер, използващ политиката за премахване на най-отдавна използвания елемент и съдържащ следните методи:

- void insert(const K& key, const V& value) - добавя нова двойка от ключ и стойност към кеша;
- std::optional\<V> get(const K& key) - връща стойност от кеша по подаден ключ;
- void evict(const K& key) - изхвърля най-отдавна използвания елемент от кеша по подадения ключ.