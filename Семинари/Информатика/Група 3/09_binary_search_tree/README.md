# СДП Семинар 9 -- Двоично дърво за търсене

## Двоично дърво за търсене

Двоично дърво, при което има наредба:

- Стойностите в **лявото** поддърво са **по-малки** от корена;
- Стойностите в **дясното** поддърво са **по-големи*** от корена.

*\*Забележка: В зависимост от конкретния случай и това как третираме повтарящи се стойности, може да се избере стойностите в дясното поддърво да бъдат по-големи или равни на корена.*

### Сравнение със сортиран масив

| Операция            | Binary Search Tree               | Sorted Array                            |
| ------------------- | -------------------------------- | --------------------------------------- |
| Търсене             | O(log n) средно, O(n) най-лошо\* | O(log n), ако се ползва двоично търсене |
| Вмъкване            | O(log n) средно, O(n) най-лошо\* | O(n) (shift)                            |
| Изтриване           | O(log n) средно, O(n) най-лошо\* | O(n) (shift)                            |
| Достъп до индекс    | -                                | O(1)                                    |
| Достъп до минимален | O(log n) най-лошо                | O(1) (първия елемент)                   |
| Достъп до минимален | O(log n) най-лошо                | O(1) (последния елемент)                |
| Обхождане           | In-order, pre-order, post-order  | Линейно                                 |
| Използвана памет    | Повече, заради указателите       | По-малко                                |

**Ако дървото се изроди до свързан списък.*

### Накратко за двоичното търсене в масив

### Задачи

#### Задача 1

Напишете функция, която по даден указател към възел на двоично дърво, проверява дали дървото, което има за корен този възел, е двоично дърво за търсене.

*Може да се възползвате от двоичното дърво от предния час.*

#### Задача 2

Реализирайте клас `BSTree`, който съдържа следните методи:

- `bool contains(const T& data)` - проверява дали има елемент в дървото с тази стойност;
- `const T& min()` - връща най-малкия елемент в двоично нареденото дърво;
- `const T& max()` - връща най-големия елемент в двоично нареденото дърво;

- `void add(const T& data)` - добавя елемента в дървото, като то продължава да бъде ДДТ;
- `void remove(const T& data)` - премехва елемента от дървото, като то продължава да бъде ДДТ.

#### Задача 3

Напишете функция `isBalanced`, който проверява дали едно BST е балансирано. Едно BST е балансирано, ако:

- е празно
- лявото му и дясното му поддърво са балансирани и разликата между височините на лявото и дясното поддърво е 0 или 1

#### Задача 4

Напишете функция `isPerfectlyBalanced`, който проверява дали едно BST е перфектно балансирано. Едно BST е перфектно балансирано, ако:

- е празно
- лявото му и дясното му поддърво са перфектно балансирани и разликата между броя елементи на лявото и дясното поддърво е 0 или 1

## Балансирано дърво. AVL

Ако остане време...
