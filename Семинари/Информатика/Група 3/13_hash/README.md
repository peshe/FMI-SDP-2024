# СДП Семинар 13 -- Хеширане. Хеш-таблица

## Хеширане

Съпоставяне на стойност за даден обект.

Например:

Обект:

```c++
struct Person
{
    std::string firstName;
    std::string lastName;
};

Person ivan = {"Pesho", "Georgiev"};
```

Хешираща функция:

```c++
int hashFunction(Person s)
{
    // assume names are not empty
    return s.firstName[0] + s.lastName[0];
}
```

## Хеш-таблица

Структура от данни, която:

- Съпоставя на ключ стойност;
- Предоставя директен достъп за **константно** време до елементите;
- Използва хешираща функция, която на даден ключ съпоставя индекс в даден масив;
- Основни операции: добавяне на двойка ключ-стойност, премахване на ключ, търсене по ключ.

Синоними: Речник

### Хеш функция

- Детерминистична
- Ефикасна и лесна за пресмятане
- „Добре“ разпределена

### Справяне с колизии

- Separate chaining
- Linear/quadratic probing
- Double hashing

## Контейнери от стандартната библиотека

- [`std::unordered_set`](https://en.cppreference.com/w/cpp/container/unordered_set)
- [`std::unordered_map`](https://en.cppreference.com/w/cpp/container/unordered_map)

### Сравнение на ДДТ и Хеш-таблица

За двоично дърво за търсене ще разгледаме червено-черно дърво, тъй като то е самобалансиращо се и се ползва най-често за имплементация на съответните контейнери от STL.

| Показател  | Червено-черно дърво                        | Хеш-таблица                    |
| ---------- | ------------------------------------------ | ------------------------------ |
| Наредба    | да, най-често <                            | няма                           |
| Търсене    | O(log(n)) - средно амортизирано и най-лошо | O(1) - средно; O(n) - най-лошо |
| Добавяне   | O(log(n)) - средно амортизирано и най-лошо | O(1) - средно; O(n) - най-лошо |
| Премахване | O(log(n)) - средно амортизирано и най-лошо | O(1) - средно; O(n) - най-лошо |

От тази таблица следват и сложностите и приложенията на `std::set`, `std::unordered_set`, `std::map` и `std::unordered_map`.

## Задачи

### Задача 1

Създайте шаблонен клас `HashTable`, който представя хеш таблица. Добавете конструктор, който приема параметър за размера на таблицата.

Добавете основните функционалности:

- `bool containsKey(const Key&)` - проверява дали в таблицата се съдържа двойка, чиито ключ е подаденият на метода параметър
- `Value get(const Key&)` - връща стойността съответстваща на подадения на метода ключ
- `void put(const Key&, const Value&)` - добавя нова двойка ключ и стойност към таблицата
- `bool empty()` - проверява дали таблицата е празна
- `int size()` - връща броя на двойките в таблицата
- `void remove(const Key&)` - премахва двойката съответстваща на подадения ключ

### Задача 2

Реализирайте допълнителни функционалности:

- `std::vector<Key> keys()` - връща всички ключове в таблицата
- `std::vector<Value> values()` - връща всички стойности в таблицата
- `double efficiency()` - изчислява съотношението на ключовете с колизия към всички ключове

### Задача 3

Направете специализация на шаблонния клас [`std::hash`](https://en.cppreference.com/w/cpp/utility/hash) за `Person` от примера по-рано.

### Задача 4

Имплементирайте [алгоритъма на Рабин-Карп](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm) за търсене на символен низ в друг.
