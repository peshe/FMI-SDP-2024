# СДП Семинар 2 - преговор на рекурсия

## Рекурсия

### Задача 1

```c++
double quick_pow(double x, int n);
```

Напишете рекурсивна функция, която пресмята $x^n$ чрез метода на бързото степенуване:

$x^n = (x^{n/2})^2, \quad$ ако $n$ е нечетно

$x^n = x.(x^{n/2})^2, \quad$ иначе

### Задача 2

Напишете функция, която отпечатва на екрана триъгълник, чийто редове се образуват по следния начин:

- най-долния ред е първоначално даден масив от цели числа;
- за всеки ред нагоре е изпълнено, че всеки негов елемент е сума на два предходни елемента „под него“.

Пример:

```
Вход: A = {1, 2, 3, 4, 5}
Изход: [48]
       [20, 28] 
       [8, 12, 16] 
       [3, 5, 7, 9] 
       [1, 2, 3, 4, 5]
```

## Backtracking

### Задача 3

```cpp
bool winning_sequence(int sequence[], std::size_t length);
```

Напишете функция, която приема редица от числа, и проверява дали следната игра може да завърши успешно:

Първо се избира едно число от редицата и се премахва от нея;
След това има 2 опции:

- избира се друго число от редицата, което се дели на избраното, и то се премахва, като се повтаря тази стъпка с него;
- избира се друго число от редицата, което дели избраното, и то се премахва, като се повтаря тази стъпка с него;

Ако по този начин могат да се премахнат всички числа, играта завършва успешно.

*Допълнение: Принтирайте последователността от ходове, ако играта е успешна.*

Пример:

```cpp
int sequence[]{42, 13, 17, 1, 3, 30, 10, 2, 6, 34, 2};
std::cout << std::boolalpha << winning_sequence(sequence, 11); // true: 42 3 30 10 2 6 2 34 17 1 13
```

### Задача 4 (за N-те царици)

Да се реализира програма, която по дадено **N**, поставя **N** на брой царици на шахматна дъска с размери **NхN**, така че те да не се застрашават една друга.
