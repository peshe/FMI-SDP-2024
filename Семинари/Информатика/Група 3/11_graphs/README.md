# СДП Семинар 11 -- Графи

## Основни понятия

Наредена двойка от върхове и ребра $G = (V, E)$

$V = \{v_1, v_2, v_3, \ldots, v_n\}, |V| = n$

$Е \subseteq (V \times V) \setminus \{(u, u) | u \in V\}, |E| = m$

- ориентиран и неориентиран (горната дефиниция е за ориентиран граф)
- с или без примки (горната дефиниция забранява примки)
- тегловен или не
- мултиграф
- свързаност (силна и слаба за ориентирани)
- с или без цикли

## Представяне в паметта

1. Матрица на съседство
    - `bool adjMatrix[][]`, където `adjMatrix[i][j]` показва дали има ребро между връх `i` и връх `j`
    - Използва се за представяне на гъсти графи (такива с много ребра)

2. Списък на съседство
    - Всеки връх има списък със съседите си, тоест към кои други върхове има ребра
      - `unordered_map<int, list<int>> adjList`, `adjList[i]` - списъкът от съседите на връх `i` // За момента не знаем какво е `unordered_map`, затова просто ще ползваме `map`
    - подходящ за разредени графи (такива с малко ребра)

3. Списък на ребра
    - `list<pair<int, int>> edges` - списък от наредени двойки, описващи ребрата между върховете
    - подходящ за проблеми, при които ребрата са осовния фокус

## Задачи

### Задача 1

Имплементирайте клас `Graph`, който представя даден ориентиран граф. Използвайте списъци на съседство и приемете, че върховете в графа са просто числа. Имплементирайте следните методи:

- `void addVertex(int vertex)` - добавя нов връх
- `void addEdge(int from, int to)` - добавя ребро между два върха
- `std::vector<int> getAdjacent(int vertex)` - връща всички върхове, към които даден връх има ребро
- `void printDot()` - отпечатва графа в `dot` формат

### Задача 2

Имплементирайте следните функции:

- `int numberOfParents(int vertex, const Graph& graph)` - намира броя на върховете в графа, които имат ребро до `vertex`
- `bool isPath(const std::list<int>& path, const Graph& graph)` - проверява дали `path` e път в графа. За примерния граф: `{1, 2, 5}` е път в графа, но `{1, 4, 6, 8}` не е.
- `bool pathExists(int from, int to, const Graph& graph)` - проверява дали съществува път в графа между два върха

### Зад. 3, DFS

Имплементирайте `std::list<int> dfs(const Graph& graph)` - връща списък на върховете в графа, обходени в последователност на DFS алгоритъма

### Зад. 4, BFS

Имплементирайте `std::list<int> bfs(const Graph& graph)` - връща списък на върховете в графа, обходени в последователност на BFS алгоритъма

### Задача 5

Реализирайте методи:

- `unsigned int connectedComponents() const`, който връща броят на свързаните компоненти за даден граф;
- `bool isCyclic() const`, който проверява дали даденият граф съдържа цъкъл.
