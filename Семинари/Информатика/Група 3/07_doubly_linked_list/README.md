# СДП Семинар 7 -- Двусвързан списък. Цикличен свързан списък

## Двусвързан списък

```cpp
template<class T>
struct DLNode {
    T data;    
    DLNode<T>* next;
    DLNode<T>* prev;
};
```

Имаме [`std::list`](https://en.cppreference.com/w/cpp/container/list) в STL за двойносвързан списък и [`std::forward_list`](https://en.cppreference.com/w/cpp/container/forward_list) за едносвързан списък.

### Сравнение с други линейни СД

| Операция                            | Singly Linked List          | Doubly Linked List    | Vector                        |
| ----------------------------------- | --------------------------- | --------------------- | ----------------------------- |
| **Добавяне в началото**             | O(1)                        | O(1)                  | O(n)                          |
| **Добавяне в края**                 | O(1)                        | O(1)                  | O(1) амортизирано             |
| **Добавяне на произволна позиция**  | O(n)                        | O(n)                  | O(n)                          |
| **Изтриване в началото**            | O(1)                        | O(1)                  | O(n)                          |
| **Изтриване в края**                | O(n)                        | O(1)                  | O(1)                          |
| **Изтриване на произволна позиция** | O(n)                        | O(n)                  | O(n)                          |
| **Обхождане**                       | O(n) (отначало само напред) | O(n) (напред и назад) | O (n) (от където искаме)      |
| **Търсене/достъп до произволен**    | O(n)                        | O(n)                  | O(1) за достъп / O(n) търсене |
| **Използвана памет**                | По-малко, разпръсната       | Повече, разпръсната   | Най-малко, последователна     |

---

*Допълнително нещо интересно: <https://en.wikipedia.org/wiki/XOR_linked_list>*

### Задачи

#### Задача 1

Реализирайте функция

```cpp
void insertSorted(DLNode<T>*& head, const T& value);
```

която добавя на правилното място *value* в двусвързан списък, подаден чрез указател към първия си елемент.

#### Задача 2

Дефинирайте функцията insertSorted от задача 1, но за `std::list`:

```cpp
template<class T>
void insertSorted(std::list<T>& ll, const T& elem);
```

## Цикличен свързан списък

- Може да бъде едно- или двусвързан списък;
- Последният елемент не сочи към NULL, а към първия (съответно и първия към последния при двусвързан);
- Има приложения за:
  - циклична опашка - например за редуващи се играчи;
  - буфер при зареждане на някакви данни;
  - други места, където се изисква „завъртане“ -- например плейлист от музика;
- Малко по-сложен за работа, защото трябва да се внимава за безкрайно зацикляне.

## Задачи (общи)

### Задача 3

Списък от цели числа се нарича **изцяло балансиран**, ако се състои от поне 3 елемента и всички елементи без първия и последния са равни на сбора от съседните си два елемента и **изцяло небалансиран**, ако в него няма нито един такъв елемент. Да се реализира функция `makeTotal`, която приема като параметър указател към първия елемент на едносвързан списък от цели числа и връща `true`, ако списъкът е изцяло балансиран. Ако списъкът не е изцяло балансиран, функцията да връща `false`, след като изтрие последователно от списъка от началото към края елементи, които изпълняват свойството за балансираност, докато списъкът стане изцяло небалансиран. За реализацията НЕ се допуска използването на допълнителни помощни структури от данни (т.е. външната (auxiliary) сложност по памет е O(1)).

Примери:

```cpp
Вход:
1 → 4 → 3 → -1 → -4 
Изход:
true
```

```cpp
Вход: 
10 → 5 → -5 → -15 → 2 
Изход:
false
10 → -15 → 2

Обяснение:
На всяка стъпка премахваме оградения в скоби елемент, защото отговаря на условието:
10 → (5) → -5 → -15 → 2 
10 → (-5) → -15 → 2
10 → -15 → 2 (списъкът вече е изцяло небалансиран)
```

### Задача 4

Нека имаме двусвързан списък от опашки и символи. Във всяка опашка от началото към края е записан валиден израз в обратна полска нотация. Операторите са [+, -, \*, /] а операндите за улеснение са **едноцифрени числа**.

Да се напише функция, която приема такъв списък, изчислява стойността на всички опашки, и връща дали списъка от резултатите е симетричен спрямо средата.

Пример:

```cpp
Вход:
      *           *     +   
      |           |     |   
      7           *     3    
      |           |     |   
+     +           7     *    
|     |           |     |    
5     6           7     3    
|     |           |     |    
4     1     8     1     2    
|     |     |     |     |    
* <-> * <-> * <-> * <-> *

Изход:
true
```

Примерът ще се оцени до 9 <-> 49 <-> 8 <-> 49 <-> 9, който е симетричен списък.
