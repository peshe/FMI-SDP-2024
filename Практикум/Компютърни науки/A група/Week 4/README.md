# Седмица 4 
 

## 1. Обръщане на елементите в опашка
Напишете програма, която обръща всички елементи в дадена опашка.

**Вход:**
```
1 2 3 2 6 12 2
```

**Изход:**
```
2 12 6 2 3 2 1
```


## 2. Проверка дали елементите в опашка образуват палиндром

Напишете програма, която проверява дали дадените елементи в опашка образуват палиндром.

**Вход:**
```
1 2 3 2 1
```
**Изход:**
```
True
```

**Вход:**
```
1 2 3 4 1
```
**Изход:**
```
False
```



## 3. Танцьори
В една танцова академия идваше време за редовното уроци по танци, но тази седмица инструкторите решиха да добавят нов елемент – танцови двойки. За целта те помолиха всички курсисти да се съберат в залата. Всяка двойка щеше да се състои от един мъж и една жена.

Програмата очаква вход в текстов формат, където всяка линия съдържа информация за пол и име на участника. Полът се обозначава с "F" за жена и "M" за мъж, следвано от името на съответния участник.

**Вход:**
```
F Penka
M Pesho
M Ivan
M Tosho
F Mariika
M Jorko
M Misho
F Ivanka
```
**Изход:**
```
Female dancer is: Penka and the male dancer is: Pesho
Female dancer is: Mariika and the male dancer is: Ivan
Female dancer is: Ivanka and the male dancer is: Tosho
There are 0 female dancers waiting to dance:
There are 2 male dancers waiting to dance: Jorko, Misho
```

>*Обяснение на примера:*
*Първата дама – Пенка, бе представена на първия мъж – Пешо. След това, на сцената се появиха Марийка и Иван. Третата двойка стана от Иванка и Тошо. Когато всички дами си намериха партньори, се оказа, че двама от мъжете останаха без двойки. Жорко и Мишо седяха на пейката, малко разочаровани, но все пак останаха да подкрепят останалите.*


## 4. Текстов редактор с история 
Създайте текстов редактор, който поддържа следните операции:
- write(char) - Записва символ в текста
- read(char) - Прочита съдържанието на текста и го принтира
- undo() - отменя последната операция извършена върху текста
- redo() - връща последната отменена операция върху текста

**Използване на програмата**
```
TextEditor();
write('a'); //a
write('b'); //ab
write('c'); //abc
write('d'); //abcd 
read(); // prints abcd
undo(); // abc
undo(); //ab
read(); //prints ab
redo(); //abc
read(); //prints abc
redo(); //abcd
read(); //prints abcd
```


## 5. Ученически стол
Има група ученици, които чакат на опашка за обяд. Всеки ученик има предпочитание за сандвич – от 1 до К. Във всеки момент има само един сандвич, който може да се вземе. Ученик взема сандвича ако съвпада с неговото предпочитание, а иначе се нарежда отново и се надява да се падне сандвич, който да му харесва. Процеса се повтаря докато всички ученици на опашката останат без сандвич.
На вход получавате N броя сандвичи и ученици и К броя видове сандвичи. На следващите 2 реда получавате по N числа. Сандвичите, които ще излизат и предпочитанията на учениците. Изведете колко от тях ще останат гладни. 

**Вход:**
```
6 4
1 2 3 4 2 1
1 1 3 2 1 4 
```

**Изход:**
```
2
```

## 6. Създайте опашка с максимален елемент

Създайте опашка, която поддържа операция за намиране на максималния елемент в текущото състояние на опашката. Получаването на максимален елемент трябва да става за амортизирана константа. 

*Забележка: Стандартните операции на опашка трябва да се поддържат и тук и сложността им не трябва да се променя*

**Използване на програмата:**
```
МаxQueue mq;
mq.enqueue(3);
mq.enqueue(2);
mq.enqueue(1);
mq.enqueue(7);
mq.enqueue(3);
mq.getMax(); //returns 1
mq.dequeue(); //remove 3
mq.dequeue(); //remove 2
mq.getMax(); //returns 1
mq.dequeue(); //remove 1
mq.getMax(); //returns 3
mq.dequeue(); //remove 7
mq.getMax(); //returns 3

```


## 7. Най-близкият по-голям елемент вдясно за всеки елемент в масив 
Даден е масив от цели числа. За всеки елемент намерете първия по-голям елемент вдясно от него и запишете индекса му в резултатен масив. Ако няма такъв запишете -1.

**Вход:**
```
5 3 4 7 8 1
```

**Изход:**
```
3 2 3 4 -1 -1
```

