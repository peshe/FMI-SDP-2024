# Задача: Морски шах

Дадена ви е недовършена игра на морски шах. Представена е като таблица със следните символи:

- Х -> играч 1
- О -> играч 2
- \- -> неизграно поле

Примерна игра:

```
X|X|O
X|-|-
O|O|-
```

Да се напише дърво, което съдържа всички възможни резултати от играта.

Да се напише програма, която отговаря на следните въпроси:

- Кой е на ход
- Играта приключила ли е
- Да се намерят всички възможни игри, в които печели X
- Да се намерят всички възможни игри, в които печели O
- Да се намерят всички възможни игри, в които не печели никой
- Да се намери най-ранно приключващите игри
- Да се намери от текущото състояние, кой ход на играча който е наред ще му осигури най-голям шанс за печалба
- Да се намери шанса на играчите да спечелят в проценти
- Да се принтират по подходящ начин всички възможни игри

Примерен изход

```
Turn: X
Game ended: false
Games where X wins:
X|X|O  X|X|O
X|X|O  X|X|O
O|O|X  O|O|X

Games where O wins:
X|X|O  X|X|O  X|X|O  X|X|O
X|X|-  X|-|X  X|O|X  X|O|-
O|O|O  O|O|O  O|O|-  O|O|X
Games where no one wins:

The fastest games:
X|X|O
X|-|X
O|O|O

The best next moves:
X|X|O  X|X|O
X|X|-  X|-|-
O|O|-  O|O|X

Player X win chance: 33.3%
Player O win chance: 66.6%



All games:

 X  | O  | X
turn|turn|turn
  |    |    |
  V    V    V

X|X|O
X|-|-
O|O|-
 |
 |    X|X|O
 |->  X|X|-
 |    O|O|-
 |      |
 |      |    X|X|O
 |      |->  X|X|O
 |      |    O|O|-
 |      |     |
 |      |     |   X|X|O
 |      |     |-> X|X|O // X wins
 |      |         O|O|X
 |      |
 |      |    X|X|O
 |      |->  X|X|- // O wins
 |           O|O|O
 |
 |    X|X|O
 |->  X|-|X
 |    O|O|-
 |      |
 |      |    X|X|O
 |      |->  X|-|X // O wins
 |      |    O|O|O
 |      |
 |      |    X|X|O
 |      |->  X|O|X // O wins
 |           O|O|-
 |
 |    X|X|O
 |->  X|-|-
      O|O|X
        |
        |    X|X|O
        |->  X|O|- // O wins
        |    O|O|X
        |
        |
        |    X|X|O
        |->  X|-|O
             O|O|X
               |
               |    X|X|O
               |->  X|X|O // X wins
                    O|O|X
```

> _Принтирането не е нужно да е точно такова_

---

# Задача: Дърво на нарастващи подредици

Дадена е редица от цели числа \( A \) с размер \( n \). Напишете програма на C++, която генерира **дърво от всички нарастващи подредици** на редицата. На всяко ниво на дървото се добавя следващото число, което е **по-голямо от последното число** в текущата подредица.



## Примерен вход:

```
A = {3, 1, 4, 2, 5}
```

## Примерно дърво:

```
(Корен)
 |
 |-- 3
 |    |-- 3, 4
 |    |      |-- 3, 4, 5
 |    |
 |    |-- 3, 5
 |
 |-- 1
 |    |-- 1, 4
 |    |      |-- 1, 4, 5
 |    |
 |    |-- 1, 2
 |    |      |-- 1, 2, 5
 |    |
 |    |-- 1, 5
 |
 |-- 4
 |    |-- 4, 5
 |
 |-- 2
 |    |-- 2, 5
 |
 |-- 5
```

---

## Изисквания:

1. Да се имплементира дървовидна структура, която представя всички **нарастващи подредици**.
2. Да се напише програма, която да отговаря на следните въпроси:
   - **Колко е височината на дървото?**
   - **Колко възли съдържа дървото?**
   - **Да се принтират всички пътища от корена до листата.**
3. Да се намерят всички нарастващи подредици с точно \( k \) числа, където \( k \) се въвежда от потребителя.
4. Да се изчисли общият брой на всички нарастващи подредици.

---

## Примерен изход:

```c++
Tree hight: 3
Number of vertices: 13
All:
3
3, 4
3, 4, 5
3, 5
1
1, 4
1, 4, 5
1, 2
1, 2, 5
1, 5
4
4, 5
2
2, 5
5

With length k:  //k = 2
3, 4
3, 5
1, 4
1, 2
1, 5
4, 5
2, 5

Count: 13
```

> _Принтирането не е нужно да е точно такова_
