# Общи задачи за практикум -- седмица 09

## Задачи за двоични дървета за търсене

### Задача 1

Дефинирайте метод, който по подаден указател към
[корен на двоично дърво](../Седмица_07/solutions/Node.h) проверява дали това дърво е двоично дърво
за търсене.

### Задача 2

Напишете функция `isBalanced`, който проверява дали дадено ДДТ е балансирано.
Едно BST е балансирано, ако:

- е празно, или
- лявото му и дясното му поддърво са балансирани и разликата между височините на лявото и дясното
поддърво е 0 или 1.

### Задача 3

Реализирайте функция за записване на двоично дърво за търсене в `std::vector`.

### Задача 4

Реализирайте функция, която по даден *сортиран* `std::vector` създава двоично дърво за търсене.

**Балансирано** ли е полученото дърво? Модифицирайте решението си, така че дървото да е балансирано
ДДТ.

### Задача 4.1

[LeetCode: 449. Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/description/)

### Задача 5

Дефинирайте следния интерфейс, представляващ структура от данни множество, която позволява ефективно
търсене, добавяне и премахване на елементи:

```cpp
template <typename T>
class Set
{
public:
    virtual bool contains(const T& data) const = 0;
    virtual void add(const T& data) = 0;
    virtual void remove(const T& data) = 0;
    virtual int size() const = 0;
    virtual bool empty() const = 0;
};
```

Добавете клас-наследник `TreeSet`, който имплементира методите с помощта на двоично наредено дърво.
За целта може да използвате
[класа от лекции за ДДТ](../../../Лекции/примери/разклонени%20СД/BinarySearchTree/BST.hpp)
или да напишете свой собствен.

### Задача 5.1

Използвайте класа `TreeSet`, за да имплементирате ефективно следните функции:

`int countUniques(const std::vector<int>& data)` - връща броя на уникланите елементи във вектора.

`bool twoSum(const std::vector<int>& data, int target)` - връща истина <=> съществуват два елемента
във вектора, чиято сума е равна на `target`.

## Задачи за префиксно дърво -- Trie

### Задача 6

Реализирайте клас `Trie`, който представя [префиксно дърво](https://en.wikipedia.org/wiki/Trie).
Достатъчно е класът да съдържа методи за добавяне, принтиране и премахване.

### Задача 6.1

Използвайки класа `Trie`, напишете функция за autocomplete, която по даден начален `string` и
префиксно дърво за речник извежда на стандартния изход всички възможни думи, започващи с този
начален низ.
