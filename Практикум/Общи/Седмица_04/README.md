# Общи задачи за практикум -- седмица 04

## Задачи за опашка

### Задача 1

Реализирайте шаблонната функция `std::queue<T> dropEverySecond(std::queue<T>)`,
която филтрира опашка, премахвайки всеки втори елемент.

```
Вход:
1 2 3 4 5
Изход:
1 3 5
```

### Задача 2

[LeetCode: 232. Имплементирайте опашка, използвайки стекове.](https://leetcode.com/problems/implement-queue-using-stacks/description/)

### Задача 3

Да се напише функция, която генерира (принтира на стандартния изход) всички двоични числа от 1 до n, използвайки опашка.

```cpp
Вход:
10
Изход:
1 10 11 100 101 110 111 1000 1001 1010
```

### Задача 4

Играем опростена версия на играта [„Експлодиращи котенца“](https://en.wikipedia.org/wiki/Exploding_Kittens). В играта има **X** играчи и **X-1** експлодиращи котета. В тестето може да има следните карти:

- O - обикновенна карта: Не прави нищо
- B - експлодиращо коте: Ако играчът няма карта "обезвреждане" губи играта. Ако се изиграе обезвреждане, котето се връща най-отдолу в колодата и чака своя нов собственик.
- S - обезвреждане: Играчът може да използва тази карта при изтегляне на екслодираща карта, така че да остане в играта. След като бъде изиграна, картата не се връща в колодата с карти.

Играчите се редуват да теглят карти, като започва първия, след него втория втория и така нататък. Ако някой изтегли експлодиращо коте и не може да се спаси, излиза от играта и не тегли повече карти.Един играч може да има неограничен брой кари обезвреждане, стига да му са се паднали. Печели този, който остане последен в играта.

Реализирайте функция `unsigned int kittens(const std::string& cards, unsigned int players)`, която на база подадено тесте карти и брой на играчи, връща номера на спечелилия играта играч.

```cpp
REQUIRE( kittens("BB", 3) == 3 );
REQUIRE( kittens("SSBB", 3) == 2 );
REQUIRE( kittens("SSBBOOOOOOOSBOOOOOOOOOSB", 5) == 1 );
REQUIRE( kittens("SOOSBBOOOOSOOOSBOSOOBOSOSOOBOSOSOOB", 7) == 3);
```

### Задача 5

[LeetCode: 1823. Find the Winner of the Circular Game](https://leetcode.com/problems/find-the-winner-of-the-circular-game/description)

### Задача 6

Разглеждаме карта на море, която е представена като матрица от 0 и 1. С 0 се означава вода, а с 1 -- земя. Остров наричаме *непразно* множество от съседни клетки земя, които имат поне една обща страна.
Реализирайте функция `unsigned int islands(const vector<vector<int>> &map)`, която намира броя острови на дадена карта.

Гарантира се, че подадената карта е валиден двумерен вектор, състоящ се от 0 и 1.

```cpp
vector<vector<int>> zeroIslands =
{
    { 0, 0, 0},
    { 0, 0, 0}
};
REQUIRE( islands(zeroIslands) == 0 );

vector<vector<int>> threeIslands =
{
    { 1, 0, 1},
    { 0, 1, 0}
};
REQUIRE( islands(threeIslands) == 3 );

vector<vector<int>> fiveIslands =
{
    { 1, 0, 1},
    { 0, 0, 0},
    { 0, 1, 1},
    { 1, 0, 0},
    { 1, 0, 1},
    { 1, 0, 0}
};
REQUIRE( islands(fiveIslands) == 5 );
```

### Задача 7

[LeetCode: 1670. Design Front Middle Back Queue](https://leetcode.com/problems/design-front-middle-back-queue/description)
