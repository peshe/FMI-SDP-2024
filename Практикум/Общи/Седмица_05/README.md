# Общи задачи за практикум -- седмица 05

## Задачи за едносвързан списък

За следващите задачи може да използвате следното представяне на възел от свързан списък:

```cpp
template <class T>
class Node {
public:
    T value;  // Стойност, съхранена във възела.
    Node<T>* next; // Указател към евентуалния следващ елемент.

    Node(T value = T(), Node* next = nullptr)
      : value(value), next(next)
    { }
};
```

### Задача 1

Да се дефинира функция `unsigned int countOf(const Node<T>* list, const T& value)`, която връща броя на срещанията на `value` в списъка `list`.

### Задача 2

Да се дефинира функция `Node<T>* removeAll(Node<T>* list, const T& value)`, която премахва всички срещания на `value` в списъка `list`.

### Задача 3

Да се дефинира функция `Node<T>* removeKth(Node<T>* list, size_t k)`, която премахва всеки k-ти елемент в списъка `list`.

```cpp
Вход:
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
k = 3
Изход:
1 -> 2 -> 4 -> 5 -> 7
```

### Задача 4

Да се напише функция `Node<T>* reverse(Node<T>* list)`, която обръща списъка `list`.

### Задача 5 (част от минало контролно)

Реализирайте функция `Node<T>* cloneReversed(Node<T>* first)`, която:

Получава указател към първия елемент на свързан списък. Създава нов списък, който съхранява същите стойности, но наредени в обратен ред. Например, ако списъкът има вида:

1 -> 2 -> 3 -> 4 -> 5

функцията създава копие, което има вида:

5 -> 4 -> 3 -> 2 -> 1

Паметта за кутиите на новия списък да се заделя с `new`. Ако по време на копирането някое от заделянията на памет не успее, функцията трябва да почисти паметта, преди да прекрати своята работа; не бива да се допуска изтичане на памет. В този случай функкцията трябва да хвърли изключение от тип `std::bad_alloc`.

Ако `first` е `nullptr`, функцията да връща `nullptr`.

### Задача 6

[LeetCode: 23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)

### Задача 7

Разглеждаме „големи“ цели положителни числа, които се представят чрез обърнат свързан списък, т.е. стойноста на единиците е първото число в този списък. Пример за такова число е 123456789012, като то се записва като `2->1->0->9->8->7->6->5->4->3->2->1`.

Да се дефинира функция `sum`, която намира сумата на 2 такива големи числа.

### Задача 8

Да се дефинира функция mirror, която добавя към свързан списък неговото огледално копие

```cpp
Вход:
1->4->5
Изход:
1->4->5->5->4->1
```

### Задача 9

[LeetCode: 143. Reorder List](https://leetcode.com/problems/reorder-list/description/)


### Задача 10
Да се реализира функция `Node<T>* getMiddle(Node<T>* first)`, която връща указател към средния елемент в едносвързан списък. Ако списъкът е с четен брой елементи, да се върне указател към "втория" среден елемент.

### Задача 11
Да се реализира функция `bool hasCycle(Node<T>* first)`, която проверява дали в едносвързан списък има цикъл, т.е. дали има кутия, която може да се достигне повече от веднъж при обхождане на списъка.

### Задача 12
Да се реализира функция `bool isPalindrom(Node<T>* first)`, която да провери дали едносвързан списък е палиндромен. Бонус би било да се ползват някои от предишните задачи и това да се постигне с константна допълнителна памет.
